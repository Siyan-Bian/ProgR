
## 正则表达式基础 (Regular Expressions Basics)

##### 核心概念与应用场景
* **定义**：模式匹配工具，用于在字符串中查找特定模式
- **典型应用**：
	- 文件名过滤（如查找所有`.doc`文件）
	- 验证输入格式（如电子邮件地址）
	- 提取URL、电话号码等结构化信息
	- 文本解析和数据清洗

##### R中的模式匹配函数族
* **查找匹配位置的函数**
```r
grep(pattern, text)      # 返回匹配元素的索引
grepl(pattern, text)     # 返回逻辑向量（TRUE/FALSE）
grep(..., value = TRUE)  # 返回匹配的值本身
```
* **查找匹配内容的函数**
```r
regexpr(pattern, text)   # 第一个匹配的位置和长度
gregexpr(pattern, text)  # 所有匹配的位置和长度（返回列表）
regexec(pattern, text)   # 第一个匹配及其捕获组
gregexec(pattern, text)  # 所有匹配及其捕获组（返回矩阵列表）
```
* **替换函数**
```r
sub(pattern, replacement, text)   # 替换第一个匹配
gsub(pattern, replacement, text)  # 替换所有匹配（global）
```
* **提取匹配内容**
```r
regmatches(text, match_result)  # 从匹配位置提取实际内容
```

##### 公共参数
* 所有函数（除`regmatches()`）都支持：
	- **`ignore.case`**：忽略大小写
	- **`fixed`**：将模式视为纯文本（忽略所有特殊字符）
	- **`perl`**：使用Perl兼容正则表达式（扩展功能）


## 基础正则表达式语法

##### 简单模式
- **纯文本**：直接匹配字符串（如`"ab"`匹配"ab"）
##### 特殊字符
* **通配符**
	- **`.`（点）**：匹配任意单个字符
	- **`.*`（点星）**：匹配任意字符，重复任意次数
* **量词（Quantifiers）**
	- **`*`**：前面的字符/组重复0次或多次
	- **`+`**：前面的字符/组重复1次或多次
	- **`?`**：前面的字符/组重复0次或1次
	- **`{n}`**：精确重复n次
	- **`{n,m}`**：重复n到m次
	- **`{n,}`**：重复至少n次
* **锚点**
	- **`^`**：字符串开头
	- **`$`**：字符串结尾
	- **`\b`**：单词边界（需要`\\b`在R中）
* **字符类**
	- **`[abc]`**：匹配a、b或c中的任意一个
	- **`[^abc]`**：匹配除a、b、c外的任意字符
	- **`[a-z]`**：匹配a到z的任意字母
	- **`[0-9]`**：匹配0到9的任意数字
	- **`[[:alnum:]]`**：字母和数字（POSIX字符类）
	- **`[[:alpha:]]`**：字母
	- **`[[:digit:]]`**：数字
* **转义字符**
	- **`\\`（双反斜杠）**：忽略下一个特殊字符的特殊含义
	    - 注意：R使用`\\`，其他语言可能用`\`
	- 示例：`\\.`匹配字面上的点，`\\*`匹配字面上的星号


## 捕获组 (Groups)

##### 组的三大功能
* **功能1：作为括号用于交替（Alternation）**
```r
"xa|by"      # 匹配"xa"或"by"
"x(a|b)y"    # 匹配"xay"或"xby"
```
* **功能2：应用量词到整个组**
```r
"x(ab)*y"    # 匹配"xy", "xaby", "xababy"等
```
* **功能3：反向引用（Backreferences）**
```r
"x(.)y\\1"   # 匹配"x"后任意字符，再"y"，再相同字符
             # 例如："xaya"匹配，"xayb"不匹配
```

##### 非捕获组
- **语法**：`(?:<text>)`
- **用途**：仅用于分组，不创建反向引用
- **示例**：
```r
"(?:ab)+"    # 重复"ab"组，但不捕获
```

##### 使用regexec()提取组
```r
pattern <- "([0-9]{4})-([0-9]{2})-([0-9]{2})"  # 年-月-日
text <- "Date: 2024-01-15"
matches <- regexec(pattern, text, perl = TRUE)
regmatches(text, matches)
# [[1]]
# [1] "2024-01-15" "2024"       "01"         "15"
#     整体匹配     第1组        第2组        第3组
```

##### gregexec()：多个匹配
- 返回**矩阵列表**：每列一个匹配，每行一个组
- 第一行：整体匹配
- 后续行：各个捕获组


## Perl扩展正则表达式 (perl = TRUE)

##### 命名组（Named Groups）
* **定义命名组**
```r
(?<group_name>pattern)
```
* **命名反向引用**
```r
\\k<group_name>
```
* **示例**
```r
pattern <- "(?<first>.)(?<second>.)\\k<second>\\k<first>"
# 匹配：任意字符(first) + 任意字符(second) + second重复 + first重复
# 例如："abba"匹配
text <- "abba cddc"
matches <- regexec(pattern, text, perl = TRUE)
regmatches(text, matches)
# 返回结果中使用组名作为名称
```

##### 前瞻与后顾（Lookahead & Lookbehind）
* **正向前瞻（Positive Lookahead）**
	- **语法**：`(?=pattern)`
	- **位置**：正则表达式末尾
	- **含义**：后面必须跟着pattern，但不包含在匹配中
- **负向前瞻（Negative Lookahead）**
	- **语法**：`(?!pattern)`
	- **含义**：后面不能跟着pattern
- **正向后顾（Positive Lookbehind）**
	- **语法**：`(?<=pattern)`
	- **位置**：正则表达式开头
	- **含义**：前面必须是pattern，但不包含在匹配中
- **负向后顾（Negative Lookbehind）**
	- **语法**：`(?<!pattern)`
	- **含义**：前面不能是pattern
- **实际示例**
```r
# 提取引号内的内容
pattern <- '(?<=").*?(?=")'
text <- 'He said "Hello" and "Goodbye"'
matches <- gregexpr(pattern, text, perl = TRUE)
regmatches(text, matches)
# [[1]]
# [1] "Hello"   "Goodbye"
```

```r
# 匹配完整单词"all"（不作为其他单词的一部分）
pattern <- "(?<![a-z])all(?![a-z])"
text <- "all tall ball"
matches <- gregexpr(pattern, text, perl = TRUE)
regmatches(text, matches)
# [[1]]
# [1] "all"  # 只匹配独立的"all"
```

##### 贪婪与非贪婪匹配
- **贪婪**：`*`, `+`, `?`, `{n,m}` 默认尽可能多地匹配
- **非贪婪**：添加`?`后缀（`*?`, `+?`, `??`, `{n,m}?`）尽可能少地匹配


## regmatches()详解

##### 基本用法
```r
text <- "abc 123 def 456"
pattern <- "[0-9]+"
matches <- gregexpr(pattern, text)
regmatches(text, matches)
# [[1]]
# [1] "123" "456"
```

##### 向量化操作
- 如果输入是多元素向量，输出也是多元素
- `gregexpr()`, `regexec()`, `gregexec()`的结果是列表

##### 赋值功能
```r
text <- "Price: $100"
pattern <- "[0-9]+"
matches <- regexpr(pattern, text)
regmatches(text, matches) <- "200"
# text现在是 "Price: $200"
```


## 综合案例：URL提取

##### 简化URL规则
- **协议指示器**：`http://`或`https://`
- **域名**：至少两个标签，用`.`分隔
    - 标签：字母、数字、连字符，不以连字符开头
- **路径**：`/`后跟字母、数字、连字符、斜杠

##### 逐步构建正则表达式
* **步骤1：协议**
```r
"https?://"  # s出现0或1次
```
* **步骤2：负向后顾（不被字母前导）**
```r
"(?<![[:alpha:]])https?://"
```
* **步骤3：域名结构**
```r
"LABEL(\\.LABEL)+"  # 第一个标签 + 至少一个".标签"
```
* **步骤4：标签定义**
```r
LABEL = "[[:alnum:]][-[:alnum:]]*"
# 开头：字母或数字
# 后续：字母、数字、连字符（0次或多次）
```
* **步骤5：路径**
```r
"/[-/[:alnum:]]*"  # 斜杠后跟路径字符
```
* **步骤6：完整正则表达式**
```r
pattern <- "(?<![[:alpha:]])https?://[[:alnum:]][-[:alnum:]]*(?:\\.[[:alnum:]][-[:alnum:]]*)+/[-/[:alnum:]]*"
```

##### 提取子部分（使用捕获组）
```r
# 提取域名
pattern <- "(?<![[:alpha:]])https?://([[:alnum:]][-[:alnum:]]*(?:\\.[[:alnum:]][-[:alnum:]]*)+)/[-/[:alnum:]]*"
#                                    ^--- 域名捕获组 ---^

text <- "Visit https://www.example.com/path"
matches <- regexec(pattern, text, perl = TRUE)
regmatches(text, matches)
# [[1]]
# [1] "https://www.example.com/path"  # 整体匹配
# [2] "www.example.com"                # 第1组（域名）
```

##### 扩展方法
- 使用`gregexec()`查找多个URL
- 使用命名组获得有意义的结果名称


## 构建正则表达式的最佳实践
##### 基本策略
- **掌握基础构建块**（见下节）
- **大量实验**：
    - 用应该匹配的字符串测试
    - 用不应该匹配的字符串测试（避免过度宽松）
- **使用工具**：
    - 交互式测试器：[https://regexr.com/](https://regexr.com/), [https://www.debuggex.com/](https://www.debuggex.com/)
    - AI辅助：[https://www.autoregex.xyz/](https://www.autoregex.xyz/)
    - StackOverflow：查找复杂模式（如完整URL、Email验证）

##### 调试技巧
- 从简单开始，逐步添加复杂性
- 分解复杂正则表达式为小部分测试
- 使用注释记录各部分功能


## 必须掌握的知识点总结

##### 函数掌握
- ✅ `grep()`, `grepl()` - 查找哪些元素匹配
- ✅ `sub()`, `gsub()` - 替换匹配内容
- ✅ `regexpr()`, `gregexpr()` - 查找匹配位置
- ✅ `regexec()`, `gregexec()` - 查找匹配及捕获组
- ✅ `regmatches()` - 提取匹配内容

##### 参数理解
- ✅ `ignore.case` - 大小写不敏感
- ✅ `perl` - 启用Perl扩展功能
- ✅ `fixed` - 纯文本匹配（无特殊字符）

##### 正则语法核心
- ✅ **特殊符号**：`. | + * ? ^ $ \\ (...) [...] [^...] [a-z] [[:...:]] {n} {n,m}`
- ✅ **捕获组**：`(...)`
- ✅ **命名组**：`(?<name>...)`
- ✅ **非捕获组**：`(?:...)`
- ✅ **前瞻/后顾**：
    - 正向：`(?=...)`, `(?<=...)`
    - 负向：`(?!...)`, `(?<!...)`

##### 实践能力
- ✅ 能够读懂给定的正则表达式
- ✅ 能够为常见模式编写正则表达式
- ✅ 能够使用捕获组提取子信息
- ✅ 理解贪婪与非贪婪匹配的区别
- ✅ 能够调试和优化正则表达式


## 常用模式速查

##### 数字
```r
"[0-9]+"           # 一个或多个数字
"[0-9]{4}"         # 精确4位数字
"\\d+"             # 等价于[0-9]+（在某些实现中）
```

##### 字母
```r
"[a-zA-Z]+"        # 一个或多个字母
"[[:alpha:]]+"     # POSIX字符类
```

##### 单词边界
```r
"\\bword\\b"       # 完整单词"word"
```

##### 电子邮件（简化版）
```r
"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}"
```

##### 日期（ISO 8601）
```r
"([0-9]{4})-([0-9]{2})-([0-9]{2})"  # YYYY-MM-DD
```


## Dev Track：模块化编程

##### 模块化原则
- **定义**：将代码分解为独立、可重用的模块
- **目标**：
    - 提高代码可维护性
    - 促进代码重用
    - 简化测试和调试

##### 在字符串处理中的应用
- 将复杂正则表达式分解为命名组件
- 创建可重用的模式验证函数
- 分离数据提取和处理逻辑

##### 示例：模块化URL处理
```r
# 模块1：协议验证
validate_protocol <- function(url) {
  grepl("^https?://", url, perl = TRUE)
}

# 模块2：域名提取
extract_domain <- function(url) {
  pattern <- "https?://([^/]+)"
  matches <- regexec(pattern, url, perl = TRUE)
  regmatches(url, matches)[[1]][2]
}

# 模块3：路径提取
extract_path <- function(url) {
  pattern <- "https?://[^/]+(/.*)"
  matches <- regexec(pattern, url, perl = TRUE)
  regmatches(url, matches)[[1]][2]
}
```


## 学习资源

##### 官方文档
- R帮助：`?regex`, `?grep`
- PCRE规范文档

##### 在线工具
- [https://regexr.com/](https://regexr.com/) - 交互式测试
- [https://www.debuggex.com/](https://www.debuggex.com/) - 可视化调试
- [https://www.autoregex.xyz/](https://www.autoregex.xyz/) - AI辅助生成

##### 速查表
- RStudio Cheat Sheet
- 正则表达式参考手册

##### 练习建议
- 从简单模式开始
- 每天练习一个新的正则概念
- 尝试解决实际数据清洗问题
- 参与StackOverflow问答