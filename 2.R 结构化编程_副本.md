
## 数据类型基础（R Track）

#### 原子类型（Atomic Data Types）

* **主要原子类型**

| 类型        | 说明                 | 检测函数                      |
| --------- | ------------------ | ------------------------- |
| logical   | 逻辑值(TRUE/FALSE)    | mode(), typeof(), class() |
| numeric   | 实数（默认 double，64 位） |                           |
| integer   | 整数                 |                           |
| character | 字符串                |                           |
| complex   | 复数                 |                           |
| raw       | 原始字节               |                           |
* **原子类型的特征**
	* **向量化**：总是"一个或多个同类型值的向量"
	* **无嵌套**：不可以递归嵌套
	- **同质性**：所有元素必须是同一类型
```r
	numeric: [1, 3]
	character: ["a", "b"]
	#不能混合：[1, "a"](除非转换)
```
* **特殊类型衍生**
	* **Factor（因子）**：
		- 内部是整数向量 + 属性 + 不同的 class
		- 用于分类数据
		
	* **Ordered（有序因子）**：
		- 类似 factor，但有序
		
		**注意**：`class()` 不一定返回单个元素

#### 递归类型（Recursive Data Types）

* **列表（List）**
	* **特征**：
		- 可以包含任何其他值
		- 支持嵌套和递归结构
		- 元素可以是不同类型
```r
numeric: [1], [1, 3]
character: ["a"], ["a", "b"]
#元素是不同类型：[1, "a"]
```


## 数据访问与索引

#### 原子类型的索引

* 单括号 `[ ]`（返回向量）
	* **用途**：访问多个元素，返回相同类型的向量
	
	**索引方式**：
	1. **整数索引**：`x[2]` → 返回第 2 个元素
	2. **逻辑索引**：`x[c(TRUE, FALSE, TRUE)]` → 按逻辑值选择
	3. **字符名称**：`x["name"]` → 按名称选择
	4. **负数**：`x[-1]` → 除了第 1 个元素外的所有

* 双括号 `[[ ]]`（返回单个元素）
	* **用途**：访问单个元素，"解包"返回值
	
	**索引方式**：
	- 单整数：`x[[1]]` → 返回第 1 个元素的内容
	- 单字符名称：`x[["name"]]`
	- **特殊用法**：`x[[c(3, 1)]]` 等同于 `x[[3]][[1]]`
```r
x <- c("a" = 1, "b" = 2)
x[1]  #返回 a 1
x[[1]]  #返回 1
```

* **命名索引**
	* 向量元素可以有名称
	- 用名称访问：`x["elem.name"]`

#### 列表的索引

* **单括号 `[ ]`（返回更小的列表）**
```r
lst <- list(num = 1, char = "a")
lst[1]  #仍返回列表 num 1
lst[[1]]  #返回 1
```

* **美元符号 `$`**
	* 按名称访问列表元素：`list$name`
	- **注意**：`$` 使用"部分匹配"，避免使用以避免歧义
	- 推荐用 `[[ ]]` 替代

#### 子集赋值（Subset Assignment）

**用途**：同时赋值多个位置
```r
x <- c(1, 2, 3)
x[c(1, 3)] <- c(10, 30) #修改第1、3个元素
#结果：[10, 2, 30]
```


## 控制结构

#### 循环（Loops）

* **For 循环**
	* **特点**
		* 对向量或列表的每个元素运行代码块
		- 列表也可以用作迭代对象
	 * **使用场景**：
		- 执行固定次数的操作
		- 对向量的每个元素进行操作（如打印、计算）
		- 对矩阵/数据框的每一行/列操作
	* **语法**
```r
for (index in vector/list) {
	#对每个元素执行代码
}
```


* **While 循环**
	*  **使用场景**
		* 不知道要重复多少次
		- 根据某个条件控制循环次数
	* **语法**
```r
while (condition) {
	#当条件为真时执行
}
```


* **Repeat 循环**
	* **等价于：** while (TRUE) { ... }
	* **使用场景**：
		* 需要在循环中间检查条件
		- 交互式运行，直到用户停止
	* **语法**
```r
repeat {
	#无限循环，必须用break跳出
}
```


* **循环控制语句**

| 语句    | 功能           |
| ----- | ------------ |
| break | 跳出当前循环       |
| next  | 跳过本次迭代，进入下一次 |
#### 条件语句（Conditionals）

* **If-Else 条件**
	* **特点：**
		* 用于**标量**（单个）逻辑值
		- 条件中只能有一个 TRUE/FALSE 值
	- **语法：**
```r
if (condition) {
	#条件为真时执行
} else {
	#条件为假时执行
}
```

* **ifelse 函数**
	* **特点：**
		* **向量化**：接受向量形式的逻辑值
		- 对向量的每个元素独立判断
	- **语法：**
```r
ifelse(conditions, value.if.true, value.if.false)
```

#### 逻辑运算符的标量 vs 向量形式

* **关键概念**

| 应用场景 | 使用的值类型        | 例子                      |
| ---- | ------------- | ----------------------- |
| 标量场景 | 单个 TRUE/FALSE | if, while               |
| 向量场景 | 向量形式的逻辑值      | ifelse, 向量索引 x[c(T, F)] |
* **运算符对比**

| 运算符  | 类型  | 用途             |
| ---- | --- | -------------- |
| &    | 向量  | 向量逻辑与          |
| \|   | 向量  | 向量逻辑或          |
| &&   | 向量  | 标量逻辑与（仅看第一个元素） |
| \|\| | 向量  | 标量逻辑或（仅看第一个元素） |
```r
x <- c(TRUE, FALSE)
y <- c(FALSE, TRUE)

x & y #[FALSE, FALSE]
x && y #FALSE（只看第一个元素）
```

* **比较操作符的陷阱**
	* `==` 返回向量形式的逻辑值
```r
x <- c(1, 2)
y <- c(1, 2)

#错误，不能直接用if
if (x == y) {...}

#正确做法：
if (identical(x, y)) {...}
if(all(x = y)) {...}
if(isTRUE(all.equal(x, y))) {...}
```


## 实用函数库

* **序列生成（Sequences）**

| 函数                | 功能                    |
| ----------------- | --------------------- |
| seq_len(n)        | 生成 1 到 n 的序列（推荐用于循环）  |
| seq_along(x)      | 生成与 x 长度相同的序列（推荐用于循环） |
| seq(from, to, by) | 自定义序列                 |
* **集合操作（Sets）**

| 函数               | 功能             |
| ---------------- | -------------- |
| setdiff(x, y)    | x 中有但 y 中没有的元素 |
| union(x, y)      | x 和 y 的并集      |
| unique(x)        | 去除重复元素         |
| setequal(x, y)   | 判断两个集合是否相等     |
| duplicated(x)    | 标记重复元素         |
| anyDuplicated(x) | 检查是否有重复        |
| table9x)         | 统计各元素出现频数      |
* **索引与查找（Indexing & Finding）

| 函数                       | 功能            |
| ------------------------ | ------------- |
| `which(x)`               | 返回 TRUE 的索引位置 |
| `which.max(x)`           | 最大值的索引        |
| `which.min(x)`           | 最小值的索引        |
| `max(x), min(x)`         | 最大值、最小值       |
| `pmax(x, y), pmin(x, y)` | 逐元素的最大/最小值    |
| `match(x, y)`            | 在 y 中查找 x 的位置 |
| `row(m), col(m)`         | 矩阵的行号、列号      |
*  **逻辑操作（Logic Operations）**

|函数|功能|
|---|---|
|`all(x)`|所有元素都是 TRUE 吗？|
|`any(x)`|任何元素是 TRUE 吗？|
|`identical(x, y)`|完全相等？|
|`all.equal(x, y)`|在数值误差范围内相等？|
|`isTRUE(x)`|是否为 TRUE？|
|`isFALSE(x)`|是否为 FALSE？|
|`xor(x, y)`|异或（exclusive or）|
* **值转换（Value Transformations）**

|函数|功能|
|---|---|
|`cut(x, breaks)`|将连续值分割成类别|
|`hist(x)`|绘制直方图|
|`diff(x)`|相邻元素的差分|
|`floor(x), ceiling(x)`|向下/向上取整|
|`round(x, digits)`|四舍五入|
|`trunc(x)`|截断小数部分|
* **向量重排（Vector Reordering）**

| 函数                       | 功能      |
| ------------------------ | ------- |
| `head(x, n)`             | 前 n 个元素 |
| `tail(x, n)`             | 后 n 个元素 |
| `append(x, y)`           | 合并向量    |
| `rep(x, times)`          | 重复元素    |
| `rep_len(x, length.out)` | 重复至指定长度 |
| `rev(x)`                 | 反向排列    |
| `sort(x)`                | 排序      |
| `order(x)`               | 排序的索引   |
| `sample(x, size)`        | 随机抽样    |
* **类型与转换（Type and Type Conversion）**

|函数|功能|
|---|---|
|`is.<TYPE>(x)`|检查是否为某类型（如 `is.numeric()`)|
|`as.<TYPE>(x)`|转换为某类型（如 `as.numeric()`)|
|`anyNA(x)`|是否包含 NA？|
|`is.na(x)`|标记 NA 值|
|`is.finite(x)`|检查有限数值|
|`mode(x), typeof(x), class(x)`|获取类型信息|
|`ordered(x), factor(x)`|创建有序/无序因子|
|`unlist(x)`|展平列表为向量|
* **字符串操作（Basic String Operations）**

|函数|功能|
|---|---|
|`nchar(x)`|字符串长度|
|`substr(x, start, stop)`|提取子串|
|`sprintf(fmt, ...)`|格式化字符串|
|`toupper(x), tolower(x)`|大小写转换|
|`paste(x, y, sep)`|拼接字符串|
|`paste0(x, y)`|无分隔符拼接|

## 编程风格（Dev Track）

#### 编程风格的重要性

* **编程的两个受众**
	* **计算机（System 2）**：
		- 不在乎代码"长什么样"
		- 只要逻辑正确就能执行
	* **人类（System 1）**：
		- 依赖第一印象、熟悉度
		- 需要快速理解，避免歧义
		- **倾向使用 System 1（感知系统）而非 System 2（思考系统）**

* **结论**
	* **代码必须同时满足**：
		1. **计算机需求**：逻辑正确（System 2）
		2. **人类需求**：易于理解（System 1）

#### 三大风格原则

* **原则 (I)：** 避免不必要的噪声与变化（Avoid Unnecessary Noise & Variation）
	**目标**：保持代码整洁、风格一致
	**具体做法**：
	- 统一的格式（不要 `a+b` 和 `a + b` 混用）
	- 统一的括号、空格使用方式
	- 统一的缩进风格
	**效果**：代码看起来整齐规范
	
* **原则 (II)**：充分利用所有通信渠道（Use All Communication Channels Available）
	* **通信渠道**：
		1. **变量/函数名称**
		2. **注释**
		3. **代码习惯用法（idioms）**

* **原则 (III)：** 你的受众有隧道视野（Your Audience has Tunnel Vision）
	* **概念**：人类在同一时间只能理解代码的一小部分
	* **具体做法**：
		* **代码分块**
			- **函数大小**：应该能在屏幕上显示（ideally ~50 行以内）
			- **文件大小**：保持合理（不要 5000 行文件）
			- **嵌套深度**：避免深度嵌套（如 for 循环嵌套在 if 嵌套在 for 中）
		* **降低认知负担**
			- **函数参数数量**：不要太多（用户不用频繁查文档）
			- **单一职责**：一个函数只做一件事（能用一句话概括）
			- **松散耦合**：减少部分代码间的依赖关系