## 可重现性 (Reproducibility) 核心概念
##### 定义层次
* **狭义定义（最严格）:** 相同代码 + 相同数据 = 相同结果
* **广义定义:**  相同代码 + 不同数据 = 相同类型的分析
	* **要求**：
		* 使用 `nrow(data)` 而非硬编码数字
		* 从数据推断假设，而非固定参数
* **最广义定义:** 他人可以使用代码和数据
	* **要求**：
		* 易于设置（依赖项有文档）
		* 代码文档完善且易懂
		* 方法描述清晰

##### 相关概念辨析

| 术语              | 含义             | 侧重点   |
| --------------- | -------------- | ----- |
| Reproducibility | 用相同代码/数据得到相同结果 | 代码层面  |
| Replicability   | 用新数据得到相同科学结论   | 科学有效性 |


## 为什么需要可重现性？
##### 节省工作量
* 场景 1: 发现分析中间有错误 → 重新运行 
* 场景 2: 新数据到达 → 自动更新分析 
* 场景 3: 项目目标轻微变化 → 调整参数重跑 
* 场景 4: 有类似新项目 → 复用代码框架

##### 专业与道德责任
* **对利益相关者**
	- **工业界**：老板、同事
	- **学术界**：其他科学家、公众
- **责任内容**
	- 让他人理解如何得出结论
	- 检查是否有错误的隐含假设
	- 便于他人在你的工作基础上继续研究
	- 通过运行代码验证设置正确


## 文件夹结构设置
##### 标准项目结构
```r
project/
 ├─ .git/              # Git 版本控制（自动创建）
 ├─ code/              # 代码文件夹
 │  ├─ data_download.R
 │  ├─ data_prep.R
 │  ├─ models.R
 │  └─ utils.R
 ├─ data/              # 数据文件夹
 │  ├─ raw/           # 原始数据
 │  │  ├─ gdp_2018.csv
 │  │  ├─ geomap.csv
 │  │  └─ oecd_survey.csv
 │  └─ intermediate/  # 中间结果
 │     ├─ model_rf.rds
 │     └─ model_gp.rds
 ├─ plots/             # 图表输出
 │  ├─ growth_vs_gini.pdf
 │  └─ map_growth.pdf
 ├─ .gitignore        # Git 忽略文件
 ├─ README.md         # 项目说明文档
 ├─ report.Rmd        # 分析报告
 ├─ settings.R        # 全局配置
 └─ source_all.R      # 加载所有脚本
```

##### 各部分详解
* **`code/` 文件夹**
	* **原则**：
		* 只包含**函数定义**
		* `source()` 这些文件不会执行任何操作（只导出函数）
		* 修改后可以重新 `source()`，无需等待
		* 文件名要能体现内容
	* **示例**：
		* normalize <- function(x) (x - min(x)) / (max(x) - min(x))
* **`data/` 文件夹**
	* `raw/` 原始数据
		* 下载或获得的原始数据
		* **永不手动编辑**
	* `intermediate/` 中间结果
		* 使用 `.rds` 格式存储 R 对象
		* **不用 `.csv`**（会丢失精度和格式）
```r
# 保存和加载
saveRDS(model, "data/intermediate/model.rds")
model <- readRDS("data/intermediate/model.rds")
```
* **`plots/` 文件夹**
	* **推荐格式**：
		* **PDF**：矢量图，缩放不失真，适合 LaTeX
		* PNG/JPG：位图，放大有像素
* **`.gitignore`**
	* **核心原则**：
		* Git 只跟踪**代码和文本**（手动创建的）
		* **不跟踪**数据和结果对象（自动生成的）
	* **原因**：
		* 避免仓库过大
		* 避免意外分享机密数据
	* **示例内容**：
```r
# .gitignore
data/
plots/
*.rds
*.pdf
.RData
.Rhistory
```
* **`README.md`**
	* **必须包含的内容**：
		* 项目做什么？
		* 需要安装什么依赖？
		* 运行什么命令获得结果？
	* **为什么用 .md**：
		* GitHub 自动渲染为网页
		* 支持标题、链接、表格、图片等
* **`settings.R`**
	* **用途**：全局配置变量
	* **原则**：
		* 只创建变量，不执行操作
		* 避免在代码中硬编码配置
* **`source_all.R`**
	* **作用**：加载所有代码文件
```r
# source_all.R
lapply(
  list.files("code",
    pattern = "\\.R$",
    ignore.case = TRUE,
    full.names = TRUE,
    recursive = TRUE
  ),
  source
)
source("settings.R")
```
* **`report.Rmd`**
	* **R Markdown 文件**：
		* 运行分析并生成 HTML/PDF 报告
		* 包含代码、图表、文字说明
		* 大项目可能有多个 `.Rmd` 文件
	* **开头示例**：
```r
source("source_all.R")
set.seed(42)  # 设置随机种子
```

##### 文件夹结构原则总结

| 原则       | 说明           |
| -------- | ------------ |
| 分离关注点    | 代码、数据、结果分开   |
| Git 版本控制 | 只跟踪源码，不跟踪生成物 |
| 相对路径     | 不使用绝对路径      |
| 可适配      | 根据项目规模调整结构   |

## 文档化 (Documentation)
##### 文档优先级顺序
* 项目是什么？ → README.md
* 需要什么依赖？ → README.md
* 如何运行？ → README.md
* 具体函数/代码做什么？ → 代码注释 + .Rmd 文件

##### README.md 标准内容
```r
# Project Name

## Description
What this project does...

## Requirements
- R >= 4.0
- Packages: tidyverse, ggplot2, ...

## Installation
```r
install.packages(c("tidyverse", "ggplot2"))
```


## 脚本化 (Scripts)
##### 交互 vs 脚本

| 模式  | 优点        | 缺点     |
| --- | --------- | ------ |
| 交互式 | 探索性强、快速试错 | 不可重现   |
| 脚本化 | 完全可重现     | 需要提前规划 |
##### 工作流建议
* **探索阶段:** 交互式 R → 试错 → 发现有用代码
* **固化阶段:** 写入脚本 → 组织为函数 → 文档化

##### 黄金原则
* 从原始数据到最终结果，脚本自顶向下运行
* 无需手动干预
* 即使命令历史被删除，也不丢失任何东西


## R Markdown (.Rmd) 文件
##### 核心优势

| 特性    | 说明           |
| ----- | ------------ |
| 文学化编程 | 文档优先，代码嵌入    |
| 分块执行  | 可单独运行代码块     |
| 缓存机制  | 保存耗时计算结果     |
| 自动报告  | 渲染为 HTML/PDF |
| 数据更新  | 更换数据自动生成新报告  |

##### 潜在风险
* **乱序执行代码块** → 导致不可重现状态
* **解决方案**：
	* 定期"Restart R and Run All Chunks"
	* 最终渲染前清除所有缓存

##### 缓存失效
* **学习重点**： 
	- 何时清除缓存？ 
	- 如何检测依赖变化？
```r
# 代码块选项 ```
{r expensive, cache=TRUE, dependson="data_prep"} 
# 当 data_prep 块改变时，此缓存自动失效
```


## 简单工作流推荐

##### 标准流程
- code/ 文件夹 → 定义函数
- settings.R → 全局配置
- source_all.R → 加载所有脚本
- report.Rmd → 执行分析  
    ├─ 开头：source("source_all.R")  
    ├─ 开头：set.seed(42)  
    ├─ 调用 code/ 中的函数  
    └─ 包含说明文字、图表

##### 组织原则
* 高层代码（.Rmd） → 分析流程、可视化  
	↑ 调用  
	低层代码（code/） → 数据处理、建模函数
* **避免**：在 `.Rmd` 中写太多底层代码


## 运行 R 的注意事项

##### 会话状态管理
* **问题：R 会话状态的隐患**
* **会话状态包括**： 
	* 1. 变量 
	* 2. `options()` 设置 
	* 3. 加载的包
* **陷阱**：
```r
rm(list = ls(all.names = TRUE))  #不能完全重置状态
```
* **解决方案**

| 操作           | 方法                                                       |
| ------------ | -------------------------------------------------------- |
| 禁用 .RData 加载 | RStudio: Tools → Project Options → 取消勾选 "Restore .RData" |
| 命令行运行        | R --no-restore-data                                      |
| 彻底重置         | 重启 R（带 `--no-restore-data`）                              |

##### 路径管理
* **错误做法**
```r
setwd("/Users/alice/projects/myproject")  # 硬编码绝对路径
```
* **正确做法**
```r
# 使用相对路径（相对于项目根目录）
data <- read.csv("data/raw/input.csv")
saveRDS(model, "data/intermediate/model.rds")
```
* **辅助工具：`here` 包**
```r
library(here)
here("data", "raw", "input.csv")
# 自动找到项目根目录并构建路径
```
* **权衡**：
	* 简化路径管理
	* 增加一个包依赖

##### 核心原则
* 不要在代码中硬编码任何特定于你的计算机的东西
* 始终从项目基础目录运行 R
* 不要使用 `setwd()`


## 自动化 (Automation)
##### 核心理念
* 手动操作 = 不可重现
* 一切自动化

##### 不要手动做的事情

| 错误操作      | 正确方法     |
| --------- | -------- |
| 手动编辑下载的数据 | 用脚本处理    |
| 复制粘贴表格到报告 | 用代码生成表格  |
| 图形编辑器调整图表 | 在代码中设置参数 |

##### R 中的自动化工具
* **文件操作函数**
```r
system2()        # 执行系统命令
dir.create()     # 创建文件夹
file.copy()      # 复制文件
file.rename()    # 重命名
file.remove()    # 删除（小心！）
```
* **Shell 脚本**
	* **Linux/Mac**：Bourne Shell
	- **Windows**：Git Bash（安装 Git 时包含）
- **优势**：
	- 适合文件夹创建、文件删除等操作
	- 跨平台脚本语言（在 DevOps 中广泛使用）


## 流水线管理 (Pipeline Management)
##### 问题背景
* **矛盾**：
	- 理论上：每个中间结果都应该能从代码重新生成
	- 实践上：有些计算非常耗时
- **需求**：
	- 保存中间结果
	- 当输入/代码改变时自动重新计算
	- 当输入/代码未改变时使用缓存

##### 方案对比
* **方案 1：手动 R 代码**
```r
result_file <- "data/intermediate/result.rds"
if (!file.exists(result_file)) {
  result <- computeResult(input)
  saveRDS(result, result_file)
} else {
  result <- readRDS(result_file)
}
```
* ✅ **优点:**
	* 简单易写
	* 清楚发生了什么
	* 无包依赖
* ❌ **缺点:**
	* 代码改变时需手动删除文件
	* 输入改变时需手动删除文件
	* 忘记删除 → 错误结果
* **方案 2：R 流水线包 (drake / targets)**
```r
# 使用 targets 包
library(targets)
tar_pipeline(
  tar_target(data, read.csv("data.csv")),
  tar_target(model, train_model(data)),
  tar_target(plot, plot_results(model))
)
```
* ✅ **优点:**
	* 自动管理缓存
	* 只做必要工作
	* 并行计算
* ❌ **缺点:**
	* 需要学习包
	* 生态系统"在变化中"
* **方案 3：Make ⭐ 推荐**
```python
#Makefile示例
results/plot.pdf: data/processed.rds code/plot.R
	Rscript code/plot.R

data/processed.rds: data/raw.csv code/process.R
	Rscript code/process.R
```
* ✅ **优点:**
	* 跨语言通用（LaTeX、C++...）
	* 存在于 1970 年代至今
	* 并行计算
* ❌ **缺点:**
	* 语法需要学习
	* Windows 需要特殊设置
	* 文件名不能有空格
* **方案 4：Snakemake / Nextflow ⭐⭐ 最推荐**
```python
#Snakemake示例
rule all:
    input: "results/plot.pdf"

rule process_data:
    input: "data/raw.csv"
    output: "data/processed.rds"
    script: "code/process.R"

rule create_plot:
    input: "data/processed.rds"
    output: "results/plot.pdf"
    script: "code/plot.R"
```
* ✅ **优点:**
	* 比 Make 更健壮、易用
	* 支持分布式计算
	* 支持容器化
	* 预存在的工作流
* ❌ **缺点:**
	* 非 R 依赖（Python）
	* 又要学新东西
* **方案 5：knitr 缓存**
```r
```{r expensive_chunk, cache=TRUE}
# 耗时计算
result <- heavy_computation()
```
* ✅ **优点:**
	* 在 .Rmd 文件内使用
	* 多数情况自动识别需要清除缓存
* ❌ **缺点:**
	* 绑定到 knitr
	* 底层文件改变需手动清除

##### 总结与建议

| 项目规模 | 推荐方案                 |
| ---- | -------------------- |
| 小项目  | 手动 R 代码 / knitr 缓存   |
| 中型项目 | Make / targets       |
| 大型项目 | Snakemake / Nextflow |
| 生产环境 | Snakemake / Nextflow |


## 工作环境影响因素
##### 场景问题
* **场景 1**：
	* 笔记本能跑，但新数据集太大
	* → 需要用研究所的计算集群
	* → 一切能正常工作吗？
* **场景 2**：
	* 导师给你一个脚本扩展
	* → 运行示例数据得到不同结果
	* → 发错脚本了？还是环境问题？

##### 影响结果的因素
数据 → 你的代码 → R包 → R版本 → 操作系统 → 硬件


## R 包版本管理
##### 问题
 * **R 包影响结果**： 
	 - 更新包版本 → 结果可能改变 
	 - 脚本突然不能运行

##### 解决方案
* **方案 1：Posit Package Manager 快照**
```r
install.packages( 
	c("tidyverse", "ggplot2"), 
	repos = "https://packagemanager.posit.co/cran/2024-01-15/" 
)
```
* **原理**：从特定日期的 CRAN 快照安装
* **方案 2：renv 包**
```r
# 初始化项目
renv::init()

# 安装包
install.packages("tidyverse")

# 保存当前包状态
renv::snapshot()

# 恢复包状态
renv::restore()
```
* **特点**：
	- 为每个项目管理独立的包库
	- 记录确切的包版本
	- 可在不同计算机间同步

##### 重要性评级
* 文件版本控制 (Git) ⭐⭐⭐⭐⭐ 必须 
* 自动化设置 ⭐⭐⭐⭐⭐ 必须 
* 包版本管理 (renv) ⭐⭐⭐ 有用但不紧急


## R 和操作系统版本
##### 影响因素
* **实例**：
```r
# R ≤ 3.6
options(stringsAsFactors = TRUE)  # 默认

# R ≥ 4.0
options(stringsAsFactors = FALSE) # 默认改变！
```
* **影响**：
	- 旧脚本在新 R 版本上可能失败
	- 行为改变导致结果不同
- **其他软件**
	- R 依赖的库（如 BLAS、LAPACK）
	- 从 R 调用的外部程序
* **操作系统**
	- Linux / Mac / Windows 差异
	- 某些 R 包在特定 OS 上不可用

##### 解决方案
* **轻量级**
```r
# 记录会话信息
sessionInfo()
# 或
devtools::session_info()
```
* **重量级：Docker 容器**
* **概念**：
	- 类似虚拟机
	- 包含操作系统、R、所有库的镜像文件
	- 在虚拟化环境中运行

| 优点       | 缺点       |
| -------- | -------- |
| 最强可重现性保障 | 学习曲线陡峭   |
| 完全隔离环境   | 文件体积大    |
| 跨平台一致    | 日常工作可能过度 |
* **何时使用**：
	- 发表的研究需要长期可重现
	- 多人协作需要环境一致
	- 生产环境部署

##### 建议策略
* **日常工作：** 记录 sessionInfo() + renv
* **重要项目：** 记录 R 版本 + OS 版本
* **发表研究：** 考虑使用 Docker


## 硬件影响
##### 可能的影响

| 因素         | 影响         | 概率  |
| ---------- | ---------- | --- |
| CPU缺陷      | 计算错误       | 极低  |
| 内存不足       | 脚本失败/错误结果  | 中等  |
| GPU vs CPU | 结果不同（神经网络） | 高   |
| 时间依赖       | 不可重现       | 高   |

##### 应对措施
* ✅ 记录和告知内存需求
* ✅ 确保有足够 RAM 
* ✅ GPU 计算要明确文档化 
* ❌ 不要依赖时间相关的计算并期望可重现

