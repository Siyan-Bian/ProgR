
## R Track：函数

* **函数基础概念**
	- **函数定义结构**：名称、参数列表、默认值、函数体
	- **返回值**：最后一条语句自动返回，或使用 `return()` 显式返回
	- **提前返回**：使用 `return()` 在函数中提前退出

- **递归（Recursion）**
	- **定义**：问题的解决方案依赖于相同问题的更小实例
	- **关键要素**：
	    - 基础情况（Base Case）：何时停止递归
	    - 递归情况：如何将问题分解为更小的子问题
	- **经典例子**：阶乘计算 `n! = n * (n-1)!`，其中 `1! = 1`
	- **特点**：在 R 中不常见，但能很好地展示函数行为

- **参数管理**
	- **默认参数值（Default Argument Values）**
		- 未提供时使用默认值，提供便利性
		- 可引用其他参数：`origin = rep(0, length(point))`
		- 函数定义时计算（惰性求值除外）
	- **参数匹配（Argument Matching）**
		- **按位置匹配**：`fun(2, 4)` 按顺序赋值
		- **按名称匹配**：`fun(to = 4, from = 2)` 位置无关
		- **混合匹配**：命名参数和未命名参数共存时，未命名的按顺序赋值
		- **部分匹配**：参数名可部分匹配（不推荐使用）
	- **缺失参数（Missing Arguments）**
		- **处理方式**：
			1. 使用默认值（首选）
			2. 使用 `missing()` 函数检查参数是否被提供
			3. 使用 `NULL` 作为默认值区分可选参数
			4. 比较：`missing()` 用于检查参数本身是否传递；`NULL` 用于检查值是否为空
		* **场景**：如 `t.test()` 中的可选参数
	* **动态参数列表（"..." 点点点）**
		* **用途**：接收可变数量的参数
		- **访问方法**：
		    - `...length()`：获取参数个数
		    - `...elt(n)`：获取第 n 个参数
		    - `list(...)`：将所有参数转为列表
		    - 直接传递给其他函数：`fun(...)`
		- **例子**：`sprintf(fmt, ...)` 根据格式字符串接收不同数量参数

- **变量作用域（Variable Scope）**
	- **词法作用域（Lexical Scoping）**
		- 函数可以访问定义时所在环境中的变量
		- 即使在函数定义后创建的变量也能访问
		- **环境链**：函数 → 定义环境 → 上层环境
	- **变量遮蔽（Variable Shadowing）**
		- 内层定义的变量覆盖外层同名变量
		- 函数参数优先于外层变量
		- 函数内赋值只影响函数内部变量，不改变外层变量
	- **变量修改**
		- 在函数内对变量赋值创建局部副本，不影响外层
		- `<<-` 操作符可修改外层变量（不推荐使用）

- **复制语义（Copy Semantics）**
	- **基本原则**：赋值创建副本，修改副本不影响原值
	- **函数中的表现**：函数参数是外部变量的副本
	- **修改方式**：函数需要返回新值，调用者重新赋值 (x <- f(x))
	- **例外**：`<-` 函数、环境、R6 类可以直接修改外层对象

- **函数作为对象（Functions as Objects）**
	- **基本概念**
		- 函数本身是对象，可赋给变量
		- `<-` 实际上是函数定义和赋值的组合
	- **高阶函数（Higher-Order Functions）**
		- **定义**：接受函数作为参数或返回函数的函数
		- **匿名函数**：无需命名，直接定义使用 (lapply(list, function(x) x^2))
		- **应用**：函数式编程的核心，实现通用操作
	- **函数式编程模式**
		- 将相同逻辑参数化为函数参数
		- 实现代码复用和高度抽象

- **do.call 函数**
	- **作用**：用列表的元素作为函数参数调用函数
	- **语法**：`do.call(fun, list(arg1, arg2, ...))`
	- **等价**：`do.call(fun, list(a, b, c))` ≈ `fun(a, b, c)`
	- **用途**：
	    - 处理 `lapply()` 的结果
	    - 动态构建函数参数
	    - 合并数据框


## 函数应用：lapply 及其家族

* **核心概念**
	* **问题**：对向量/列表/矩阵的每个元素/行/列应用函数
	- **最简单情况**：向量化操作
	- **通用方案**：`lapply` 及其变体

- **lapply（List Apply）**
	- **功能**：对列表的每个元素应用函数，返回列表
	- **语法**：`lapply(X, FUN, ...)`
	- **特点**：
	    - 返回结果总是列表
	    - 支持匿名函数
	    - 额外参数可直接传递给 FUN
	- **用途**：当需要保留列表结构时

- **sapply（Simplified Apply）**
	- **功能**：`lapply` 的简化版，尝试将结果简化为向量或矩阵
	- **返回类型**：
	    - 所有元素标量 → 向量
	    - 所有元素向量且等长 → 矩阵
	    - 无法简化 → 列表
	- **注意**：字符向量会被转为列表名称
	- **风险**：结果类型不确定，易出错

- **vapply（Verified Apply）★ 推荐使用**
	- **功能**：`sapply` 的类型安全版本
	- **关键参数**：`FUN.VALUE` 指定期望的返回类型
	- **优势**：
	    - 类型检查，类型不匹配报错
	    - 更快更安全
	    - 代码自文档化
	- **指定返回类型**：
	    - 单标量值 → 简化为向量
	    - 向量 → 简化为矩阵
	    - 长度不一 → 错误（类型安全）

* **mapply（Multivariate Apply）**
	- **功能**：对多个向量/列表并行应用函数
	- **语法**：`mapply(FUN, list1, list2, ...)`
	- **特点**：按位置同步迭代多个输入
	- **例子**：`mapply(function(a,b) a^b, c(1,2,2,3), c(3,2,1,2))`

* **Map 函数**
	* **功能**：类似 `mapply`，但不简化结果
	- **关系**：`Map` vs `mapply` 如同 `lapply` vs `sapply`

* **apply 函数**
	* **功能**：对矩阵的行或列应用函数
	- **语法**：`apply(matrix, MARGIN, FUN)`
	- **MARGIN 参数**：
	    - `1`：行（row-wise）
	    - `2`：列（column-wise）
	- **记忆法**：矩阵 `[行, 列]` → 1=行，2=列
	- **快捷函数**：`rowSums()`, `colSums()`, `rowMeans()`, `colMeans()`

* **tapply（Tabulate Apply）**
	* **功能**：按组应用函数（分组计算）
	- **语法**：`tapply(X, INDEX, FUN)`
	- **INDEX**：指定每个元素的组别
	- **用途**：按类别统计、分组汇总
	- **扩展**：可用于数据框的分组操作

* **rapply（Recursive Apply）**
	* **功能**：递归应用函数于嵌套列表中特定类的所有实例
	- **使用频率**：较低
	- **适用场景**：处理复杂嵌套结构

* **Reduce 函数**
	* **功能**：将二元函数依次应用于列表/向量元素及前一次结果
	- **用途**：累积计算
	- **例子**：
	    - `Reduce("+", c(1,2,3,4))` → `((1+2)+3)+4` = 10
	    - 实现 `sum`、`cumsum` 等累积操作

* **Filter 函数**
	* **功能**：返回谓词函数为 TRUE 的元素
	- **语法**：`Filter(predicate, list)`
	- **特点**：筛选，不改变结构
	- **替代**：通常可用向量化索引替代

* **Find 函数**
	* **功能**：返回第一个（或最后一个）满足谓词的元素
	- **参数**：`right = TRUE` 从右边搜索
	- **对比**：`Filter` 返回所有，`Find` 返回单个

* **Position 函数**
	* **功能**：返回满足谓词的元素的位置
	- **对比**：`Find` 返回元素值，`Position` 返回索引

* **replicate 函数**
	* **功能**：重复计算表达式 n 次
	- **特点**：不接受函数，而是表达式
	- **用途**：随机抽样、交互式模拟实验
	- **参数**：`simplify = FALSE` 返回列表而非向量/矩阵

* **函数使用层级（重要程度）**

| 层级    | 函数                           | 说明              |
| ----- | ---------------------------- | --------------- |
| Tier1 | lapply, sapply, **vapply**   | 必须掌握，vapply 最推荐 |
| Tier2 | apply, mapply/Map, replicate | 常用，应该了解         |
| Tier3 | Filter, Reduce, tapply       | 有用的技巧，不常用       |
| Tier4 | rapply, Find, Position       | 少见场景            |
* **lapply vs 循环**
	* **方式 1：简单循环**
	    - 优点：直观
	    - 缺点：累积赋值（`result <- c(result, ...)` ）效率低
	- **方式 2：预分配循环**
	    - 优点：效率高
	    - 缺点：代码多，易出错
	- **方式 3：`lapply/sapply`** ★ 推荐
	    - 优点：代码简洁，无需预分配，效率好
	    - 缺点：函数式思维学习曲线
	- **方式 4：向量化**
	    - 优点：最快，最简洁
	    - 缺点：不是所有操作都能向量化

* **purrr 包（进阶，不讲授）**
	* tidyverse 的函数应用包
	- 提供更多语法糖
	- 风险：引入代码依赖，可能破坏向后兼容性
	- 建议：在交互式工作中可用，生产代码需谨慎


## Tools Track：checkmate 包

* **断言编程概念（Assertions）**
	* **为什么需要断言**
		* **隐式假设**：函数对输入做出假设
		    - 参数类型、范围、长度等
		    - 库函数返回值的结构
		    - 重构后参数类型改变
		- **问题**：违反假设会导致
		    - 晦涩的错误消息（坏）
		    - 静默运行，产生错误结果（更坏）
	- **解决方案**
		- **防御性编程**：显式检查约束条件
		- **设计契约**：函数开始处检查前置条件
		- 给出明确的错误消息

* **checkmate 包概述**
	* **功能**：检查变量的约束条件（类型、长度、值域等）
	- **风格**：同时提供 snake_case 和 camelCase 函数
	- **课程要求**：使用 camelCase 函数

* **checkmate 四种函数类型**
	* **test* 函数**
		* **返回值**：逻辑值（TRUE/FALSE）
		- **用途**：条件检查
		- **例子**：`testInt(x)` → `TRUE` 或 `FALSE`
	- **assert** 函数 ★ 最常用
		- **返回值**：不可见地返回值（约束满足）或抛出错误
		- **特点**：
		    - 满足条件：返回值本身，无输出
		    - 不满足：抛出有意义的错误消息
		- **用途**：函数开始处验证参数
		- **例子**：`assertInt(x)` 满足则无输出，否则报错
	- **check 函数**
		- **返回值**：TRUE（满足）或错误描述字符串（不满足）
		- **用途**：构建复杂的条件逻辑（与 `assert()` 组合）
		- **特殊用法**：`assert(checkA(...), checkB(...), ...)` 检查多个 OR 条件
	- **expect 函数**
		- **在 testthat 测试框架中使用**
		- **本课程暂不涉及**

* **checkmate 检查类型**
	* **标量检查（Scalar Checks）**
		* 前缀用 `assert/check/test`
			- **Flag**：逻辑值 TRUE/FALSE
			- **Count**：非负/正整数
			- **Number**：单个数值
			- **Int**：整数（包括接近整数的值）
			- **String**：单个字符串
			- **ScalarNA**：单个 NA 值
	- **向量检查（Vector Checks）**
		- **对应 `is.XXX()` 的所有函数**：
		    - Logical, Numeric, Double, Integer, Character, Complex, Factor, List, POSIXct, Raw, Vector, Atomic, Null
		- **特殊向量检查**：
		    - **Integerish**：整数或接近整数的值
		    - **AtomicVector**：原子向量（排除 NULL 和数组）
	- **其他类型检查**
		- **容器**：Array, DataFrame, Matrix, Date, Function, Formula
	- **集合检查（Sets）**
		- **Subset**：元素是否为某集合的子集
		- **Choice**：是否为给定选择之一
		- **SetEqual**：是否与给定集合相等
		- **Disjunct**：是否为不相交集合

* **checkmate 常见参数**

| 参数          | 默认值   | 说明                 | 适用       |
| ----------- | ----- | ------------------ | -------- |
| null.ok     | FALSE | 接受NULL             | 大多数      |
| na.ok       | FALSE | 接受NA               | 标量       |
| any.missing | TRUE  | 允许部分NA             | 向量       |
| all.missing | TRUE  | 允许全部NA             | 向量       |
| len         | -     | 精确长度               | 向量       |
| min.len     | -     | 最小长度               | 向量       |
| max.len     | -     | 最大长度               | 向量       |
| unique      | FALSE | 值是否唯一              | 向量       |
| names       | -     | "names" 或 "unique" | 向量/列表    |
| sorted      | FALSE | 是否升序排列             | 向量       |
| lower       | -     | 下界                 | 数值       |
| upper       | -     | 上届                 | 数值       |
| finite      | -     | 是否有限(排除 Inf)       | 数值       |
| tol         | -     | 容差(整数检查)           | checkInt |
| .var.name   | -     | 错误消息中的变量名          | assert   |
* **标量 vs 向量函数的 NA 处理差异**
	* **标量函数**：默认 `na.ok = FALSE`（不接受 NA）
	- **向量函数**：默认 `any.missing = TRUE`, `all.missing = TRUE`（接受 NA）
	- **原因**：标量不应为 NA，向量可以包含 NA

* **辅助运算符：%??%**
	* **功能**：如果左侧非 NULL 则返回左侧，否则返回右侧
	- **语法**：`value %??% default`
	- **用途**：设置默认值
	- **例子**：`function(x = NULL) { x <- x %??% 10 }`

* **提高错误消息质量**
	* **`.var.name` 参数**：在 assert* 函数中指定变量名
	- **作用**：错误消息中显示原始参数名，而非函数调用中的表达式
	- **示例**：
```r
assertint(input$value, .var.name = "input$value")
```

* **使用案例集锦**
	* **基本检查**：`assertInt(x, lower = 1)` / `assertCount(x, positive = TRUE)`
	- **向量检查**：`assertNumeric(x, min.len = 1, max.len = 10)`
	- **可选参数**：`assertNull(x) | assertCharacter(x)`
	- **转换赋值**：`x <- assertInt(x, tol = 0)` 同时验证和类型转换
	- **多个 OR 条件**：
```r
assert(
	checkInt(x),
	checkCharacter(x),
	checkFunction(x)
)
```


## 综合对比总结

##### 函数应用方法对比

| 方法     | 用途    | 优点    | 缺点      | 推荐场景    |
| ------ | ----- | ----- | ------- | ------- |
| 向量化    | 元素级操作 | 最快    | 依赖向量化函数 | 简单数学运算  |
| 循环     | 通用操作  | 直观可控  | 代码多、效率低 | 逻辑复杂时   |
| lapply | 列表操作  | 代码简洁  | 返回列表    | 需要列表结果  |
| sapply | 简化结果  | 结果紧凑  | 结果类型不确定 | 交互式工作   |
| vapply | 类型安全  | 报错清晰  | 需指定返回类型 | 生产代码    |
| apply  | 矩阵操作  | 专用于矩阵 | 不适用其他结构 | 矩阵行/列操作 |

##### checkmate 函数选择

| 场景       | 函数                                | 示例                      |
| -------- | --------------------------------- | ----------------------- |
| 必需整数     | assertInt                         | assertInt(n, lower = 1) |
| 必需正整数    | assertCount(..., positive=TRUE)   | -                       |
| 非负整数     | assertCount                       | -                       |
| 可选参数     | is.null(x) \| assertXxx(x)        | -                       |
| 多个 OR 选项 | assert(check...(), check...())    | -                       |
| 数据框列     | assertDataFrame(df, nrows=5)      | -                       |
| 矩阵维度     | assertMatrix(m, nrows=3, ncols=4) | -                       |


## 关键知识速查表

* **函数基础**
	* 函数三要素：名称、参数、体
	- 递归需要：基础情况 + 递归情况
	- 参数匹配：位置 > 名称 > 默认值
	- 作用域：词法作用域，内层遮蔽外层

* **lapply 家族速记**
```r
lapply(X, FUN, ...)        # 通用，返回列表
sapply(X, FUN, ...)        # 尝试简化（不推荐）
vapply(X, FUN, FUN.VALUE)  # 类型安全 ★推荐
mapply(FUN, X, Y, Z, ...)  # 多向量并行
apply(MAT, 1/2, FUN)       # 矩阵行/列 (1=行, 2=列)
tapply(X, INDEX, FUN)      # 分组计算
Reduce(FUN, X)             # 累积计算
Filter(PRED, X)            # 筛选
```

* **checkmate 快速参考**
```r
assert + Scalar 名称  # 标量检查：Flag, Count, Number, Int, String
assert + 类型名词      # 向量检查：Numeric, Character, Logical, ...
assert + 数据结构      # 结构检查：DataFrame, Matrix, Array, Function
+ null.ok / na.ok     # 允许 NULL 或 NA
+ .var.name           # 错误消息中的变量名
```