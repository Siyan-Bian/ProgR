## Ex1: 内连接
* 通过 `product.id` 内连接  `products` 和 `orders` 两个 data.table
```r
mergeProductInfo <- function(orders, products) {
  assertDataTable(orders)
  assertDataTable(products)
  assertNames(colnames(orders), must.include = "product.id")
  assertNames(colnames(products), must.include = "product.id")
  # your code
  merge(orders, products, by = "product.id")
}
```
* **merge():** 合并与连接

## Ex2: 左连接
* 连接 `products` 到 `orders` , 保留 `orders`所有行
* 替换 `product.name` 列中的 **NA** 为 `"Unknown Product"`
```r
createSalesReport <- function(orders, products) {
  assertDataTable(orders)
  assertDataTable(products)
  # your code
  # merge() 方式
  result <- merge(orders, products, by = "product.id", all.x = TRUE)
  #                                                      ^^^^^^^^^^
  #                                           保留左表(orders)所有行
  
  # data.table 方式(默认就是 left join)
  # result <- products[orders, on = "product.id"]
  #           ^^^^^^^^ ^^^^^^
  #            右表      左表 - 保留左表所有行                              
  # 替换 NA
  result[is.na(product.name), product.name := "Unknown Product"]
  result
}
```

## Ex3: 更新连接
```r
addRevenue <- function(orders, products) {
  assertDataTable(orders)
  assertDataTable(products)
  # your code
  # 从 products 中查找 price，添加到 orders 表
  orders[products, price := i.price, on = "product.id"]
  
  #计算 revenue 列
  orders[, revenue := quantity * price]
  
  #返回修改后的 orders
  orders
}
```
* `i.price`: 取 `products` 表中的 `price` 列

## Ex4: 反向连接
* 过滤 `customers` 表，返回只在 `customers` 表中但不在 `orders` 表里的行
```r
findInactiveCustomers <- function(customers, orders) {
  assertDataTable(customers)
  assertDataTable(orders)
  # your code
  customers[!orders, on = "customer.id"]
}
```

## Ex5: 滚动连接
* `orders`表有 `date` 列，`price.history` 表有 `valid.from` 列
* 使用 `roll = TRUE` 将 `price.history` 连接到 `orders` 中
* 连接方式: `product.id` 以及 `valid.from = date`
```r
matchHistoricalPrices <- function(orders, price.history) {
  assertDataTable(orders)
  assertDataTable(price.history)
  # your code
  price.history[orders,
                on = .(product.id, valid.from = date),
                roll = TRUE]
  #             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #             连接条件：product.id 相同 且 valid.from <= date
  #                                            ^^^^^^^^^^^
  #                                  自动找到 valid.from <= date 的最大值
  #             roll = TRUE：向前滚动查找最近的有效价格
}
```
* `x[i, ...]` 的规则：保留 `i` 的所有行
* **roll** 参数值:
	* roll =TRUE / Inf -----向前滚动（找 ≤ 的最近值）
	* roll = -Inf -----向后滚动（找 ≥ 的最近值）
	* roll = n -----最多滚动 n 个单位
	* roll = "nearest" -----找最接近的（前或后）