## Ex1: 按条件选择
**dplyr:**
```r
expected.1 <- sales.data %>% 
  filter(store.loc == "Berlin")
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
result.1 <- dt[store.loc == "Berlin"]
```
* 直接使用 `data[condition]` 选取子集

## Ex2：选择多列
**dplyr:**
```r
expected.2 <- sales.data %>% 
  select(txn.id, date)
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
result.2 <- dt[, .(txn.id, date)]  #.() 是 list() 的简写
#等价于
#result.2 <- dt[, list(txn.id, date)]        
#result.2 <- dt[, c("txn.id", "date")]      
#result.2 <- dt[, c(1, 4)]                  
```

## Ex3：升序降序
**dplyr:**
```r
expected.3 <- sales.data %>% 
  arrange(desc(date))
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
result.3 <- dt[order(-date)]
```
* `data[order(-列名)]`: 降序
* `data[order(列名)]`: 升序

## Ex4：新增列
**dplyr:**
```r
expected.4 <- sales.data %>% 
  mutate(is.bulk = quantity > 3)
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
#修改并返回（推荐用于赋值）
result.4 <- dt[, is.bulk := quantity > 3][]
```
* 直接修改（不返回）: `dt[, is.bulk := quantity > 3]`
* 创建新对象而不修改原对象: `result.4 <- copy(dt)[, is.bulk := quantity > 3][]`
* 新增多列：
	* `dt[, c("is.bulk", "total") := .(quantity > 3, quantity * 10)]
	* `dt[, c("is.bulk", "total") := list(quantity > 3, quantity * 10)]
	* `:=` 函数式写法：`dt[, :=(
						  col1 = expr1,
						  col2 = expr2,
						  col3 = expr3
						)]`

## Ex5：分组聚合
**dplyr:**
```r
expected.5 <- sales.data %>% 
  group_by(store.loc) %>% 
  summarise(total.qty = sum(quantity)) %>%
  ungroup() %>%
  arrange(store.loc)  #自动排序
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
# 使用 `.()` 创建新数据表，返回新数据表，不修改原表
result.5 <- dt[, .(total.qty = sum(quantity)), by = store.loc][order(store.loc)]
```
* `data[, .(新列 = 聚合函数(列)), by = 分组列]`
	* **`by` 参数** --- 在第三个位置，用于指定分组变量
	- **`.()` 在 `j` 位置** --- 定义聚合结果的列
	- **需要手动排序** --- `data.table` 不会自动按分组变量排序

## Ex6：链式操作（筛选 -> 分组 -> 汇总）
**dplyr:**
```r
expected.6 <- sales.data %>% 
  filter(product.id %in% c("P01", "P02")) %>%   #筛选
  group_by(product.id) %>%   #分组
  summarise(mean.qty = mean(quantity)) %>%   #汇总
  arrange(product.id)  #排序
```
**data.table:**
```r
result.6 <- dt[product.id %in% c("P01", "P02"),  #i: 筛选行
               .(mean.qty = mean(quantity)),  #j: 计算
               by = product.id  #by: 分组
               ][order(product.id)]  #链式排序
```

## Ex7：左连接
**dplyr:**
```r
expected.7 <- sales.data %>% 
  left_join(products.data, by = "product.id") %>%
  arrange(txn.id)
```
**data.table:**
```r
dt.sales <- copy(sales.data)
dt.prods <- copy(products.data)
# your code
result.7 <- merge(dt.sales,  #左表
				  dt.prods,  #右表
                  by = "product.id",  #连接键
                  all.x = TRUE  #左连接（保留左表所有行）
                  )[order(txn.id)]  #排序
```
* `merge(x, y, by, all, all.x, all.y, ...)`
	* x: 左表
	* y: 右表
	* by: 连接键（单个或多个）
	* all: 全外连接（保留两表所有行）
	* all.x: 左连接（保留左表所有行）
	* all.y: 右连接（保留右表所有行）

## Ex8：切片
**dplyr:**
```r
expected.8 <- sales.data %>% 
  arrange(desc(quantity)) %>% 
  slice_head(n = 3)
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
result.8 <- dt[order(-quantity)][1:3]
```
* 取前n行：`dt[1:n]`
* 取后n行：`tail(dt, n)`
* 取特定位置的行：`dt[c(a, b, c)]`
* 取最大值的行：`dt[order(-quantity)][1:n]`
* 取最小值的行：`dt[order(quantity)][1:n]`
* 按比例取样(z.B. 取前10%)：`dt[1:(.N * 0.1)]`

## Ex9：去重
**dplyr:**
```r
expected.9 <- sales.data %>% 
  distinct(store.loc, product.id) %>% 
  arrange(store.loc, product.id)
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
result.9 <- unique(dt[, .(store.loc, product.id)])[order(store.loc, product.id)]
```
* 对指定列去重，保留所有列：`unique(dt, by = c("store.loc", "product.id"))`
* 对指定列去重，只保留这些列：`unique(dt[, .(store.loc, product.id)])`
* **order():**
	* 全部升序：order(x, y, z, ...)
	* 全部降序：order(-x, -y, -z, ...)
	* 混合排序(升序+降序)：order(x, -y, z, ...)

## Ex10：分组计算并添加新列
**dplyr:**
```r
expected.10 <- sales.data %>% 
  group_by(store.loc) %>% 
  mutate(store.share = quantity / sum(quantity)) %>% 
  ungroup() %>%
  arrange(txn.id)
```
**data.table:**
```r
dt <- copy(sales.data)
# your code
result.10 <- dt[, store.share := quantity / sum(quantity), by = store.loc][order(txn.id)]
```
* **`:=`**：在原 data.table 上**直接修改**（不创建副本）
* **`by = store.loc`**：按店铺分组