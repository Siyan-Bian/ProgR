## Ex1: 返回数据框的奇数列
```r
oddCols <- function(df) {
  # your code 
  df[, seq(1, ncol(df), by = 2), drop = FALSE]
}
```
* **默认 (drop = TRUE)**: 得到一个向量，丢失了列名，也丢失了 data.frame 的属性
- **显式设置 (drop = FALSE)**: 无论剩下几列（哪怕只有 1 列），它依然保持为一个 `data.frame`
- **总结:** `drop = FALSE` 就像是给你的数据框套了一个“保形罩”，告诉 R：“无论我切得多么小，请维持它原来的形状（data.frame），不要把它压扁成向量

## Ex2: 服务台排队系统
 * 想象你在银行柜台排队：
	- **输入**：一个列表 `arrivals`。列表的每个元素代表一个“时间点”。在该时间点，可能会有 0 个、1 个或多个（向量）新客户到达并加入队尾
	- **动作**：在每一个时间点，服务台**只能接待一个人**（队列最前面的人）
	- **输出**：一个列表 `served`。记录每个时间点是谁被接待了。如果当时没人排队，则记录为 `NULL`
- **核心思路讲解** (以例子中的 Time 1 和 Time 2 为例):
	- **Time 1**: Alice 和 Bob 到达。队列变成 `c("Alice", "Bob")`。接待 Alice（队首），队列剩下 `c("Bob")`
	- **Time 2**: Charlie 到达。加入队尾，队列变成 `c("Bob", "Charlie")`。接待 Bob（队首），队列剩下 `c("Charlie")`
```r
queueSimulation <- function(arrivals) {
  # 初始化
  queue <- c()      # 存储当前正在排队的人（等待区）
  served <- vector("list", length(arrivals))  # 预分配内存

  # 遍历每一个时间点
  for (i in seq_along(arrivals)) {
    
    # 步骤 A: 把当前时间点新到的人加到队尾
    queue <- c(queue, arrivals[[i]])

    # 步骤 B: 检查队列里是否有人
    if (length(queue) > 0) {
      # 如果有人，接待队首第一人
      served[[i]] <- queue[1]
      # 关键步骤：更新队列，把已经接待的第一人踢出去 (队首出队)
      queue <- queue[-1] 
    }
  }
  return(served)
}
```
* 为什么初始化时不使用 `served <- list()`?
	* 因为在 List 中，给一个不存在的索引赋值 NULL，列表不会增长
	* 使用预分配内存的方法，这样`served[[i]]` 就不再是“创建新位置”，而是“替换已有位置”

## Ex3: 指数平滑
* 递归定义的公式：
	- **起始值**：$s[1]=x[1]$（第一个平滑值直接等于原始数据的第一个值）
	- **递归项**：$s[i]=α⋅x[i]+(1−α)⋅s[i−1]$
	    - $α$ 是平滑参数
	    - 这个公式的意思是：当前的平滑值由“**当前的原始观测值**”和“**上一个时间点的平滑值**”共同决定
```r
expSmooth <- function(x, alpha) {
  # your code
  # 处理边界情况（空向量）
  if (length(x) == 0) {
    return(numeric(0))
  }
  
  # 初始化结果向量
  s <- numeric(length(x))
  
  # 第一个元素
  s[1] <- x[1]
  
  # 计算后续元素
  if (length(x) > 1) {
    for (i in 2:length(x)) {
      s[i] <- alpha * x[i] + (1 - alpha) * s[i - 1]
    }
  } 
  return(s)
}
```

## Ex5: 矩阵切片函数
* **题目规则解析**
	- **输入**：一个带有列名（column names）的矩阵 `mat`
	- **核心任务**：找到列名为 `"ID"` 的那一列
	- **切除规则**：保留 `"ID"` 列及其右侧的所有列，丢弃 `"ID"` 左侧的所有列
	- **特殊情况 1（多个 ID）**：如果矩阵中有多个列都叫 `"ID"`，以**最后一个**（最右边那个）为准
	- **特殊情况 2（没有 ID）**：如果没有列叫 `"ID"`，题目虽然没明说，但通常稳健的写法是返回原矩阵或处理报错
```r
reduceMatrix <- function(mat) {
  # your code
  #获取列序号
  id_cols <- which(colnames(mat) == "ID")
  
  #特殊情况
  if (length(id_cols) == 0) {
    return(mat)
  }
  
  #可能有多个ID列，找到最后一个ID列
  last_id <- max(id_cols)
  
  #保留从最后一个ID列到最后一列，并保留矩阵形式
  return (mat[, last_id : ncol(mat), drop = FALSE])
}
```