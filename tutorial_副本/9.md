## Ex1: 数据框转换为 data.table 并筛选
* 筛选出 `top.speed` 在100和500之间
```r
prepareFleet <- function(fleet.data) {
  assertDataFrame(fleet.data)
  assertNames(colnames(fleet.data), must.include = c("top.speed"))
  # your code
  #转换为 data.table
  setDT(fleet.data)
  
  #筛选条件
  fleet.data <- fleet.data[top.speed >= 100 & top.speed <= 500]
  
  return(fleet.data)
}
```
* **setDT():** 转换为 data.table

## Ex2: data.table 新增列
```r
addFleetMetrics <- function(dt) {
  assertDataTable(dt)
  assertNames(colnames(dt), must.include = c("top.speed", "crew.size"))
  # your code
  # 添加 speed.sq 列（速度的平方）
  dt[, speed.sq := top.speed^2]
  # 添加 ratio 列（速度/船员比）
  dt[, ratio := top.speed / crew.size]
  # 处理无穷大的情况（crew.size = 0）
  dt[is.infinite(ratio), ratio := NA_real_]
  
  return(dt)
}
```

## Ex3: 创建新的 data.table
```r
summarizeClasses <- function(dt) {
  assertDataTable(dt)
  # your code
  #.() 创建新的 data.table
  dt[, .(  
    ship.count = .N,  #.N 是 data.table 的特殊符号，表示当前分组的行数
    avg.speed = mean(top.speed),
    max.crew = max(crew.size)
  ), by = class]
}
```
* 用 .() 返回 data.table，可以命名多列

## Ex4: 查找列并操作
* 筛选出列名以 `"sensor"` 开头的列
* 对这些列四舍五入到整数
```r
roundSensorData <- function(dt) {
  assertDataTable(dt)
  # your code
  # 找到所有以 "sensor" 开头的列名
  sensor_cols <- grep("^sensor", names(dt), value = TRUE)
  #                               ^^^^^^^^^  ^^^^^^^^^^^^
  #                             从列名中搜索 返回匹配的列名(而不是索引)
  
  # 对这些列进行四舍五入（in-place）
  # 有括号：sensor_cols 被当作变量，展开为 c("sensor1", "sensor2")
  # 无括号：data.table 会认为你要创建一个叫 "sensor_cols" 的新列
  dt[, (sensor_cols) := lapply(.SD, round), .SDcols = sensor_cols]
  #    ^^^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^
  #     更新这些列      对每列应用 round         指定操作的列
  
  return(dt)
}
```
* **":="**: 修改 / 新增列
* **"="**: 传递参数
* `.SD` 是 **S**ubset of **D**ata 的缩写，表示当前操作的数据**子集**
	* 配合 `.SDcols` 指定**操作哪些列**
* **grep():**
	* 筛选列名:
		* grep("speed$", names(dt))  -----返回位置索引 
		* grep("speed$", names(dt), value = TRUE)  -----返回列名本身
	* 筛选符合条件的行:
		* dt[grep("Scout", class)]  -----找出名字包含 "Scout" 的行
	* 从向量中筛选元素:
		* fruits <- c("apple", "banana", "apricot", "cherry")
		* grep("^a", fruits)  -----返回 1, 3
		* grep("^a", fruits, value = TRUE)  -----返回 "apple", "apricot"
	*  **grepl():** 逻辑向量 (TRUE/FALSE)
		* grepl("^a", fruits)  -----返回 c(TRUE, FALSE, TRUE, FALSE)
	* 和 `regmatches() + regexpr()` 的区别:
		* grep(..., value=TRUE) 匹配的**整个元素**
		* regmatches(regexpr()) 匹配的**具体部分**
```r
x <- c("speed_100", "crew_50", "speed_200")

# grep: 返回包含数字的整个字符串
grep("\\d+", x, value = TRUE)
# 返回: "speed_100" "crew_50" "speed_200"

# regmatches: 只提取匹配到的数字部分
regmatches(x, regexpr("\\d+", x))
# 返回: "100" "50" "200"
```

## Ex5
```r
createLogbooks <- function(dt) {
  assertDataTable(dt)
  # your code
  # 创建 specs 列表列
  dt[, specs := lapply(.I, function(i) {
    c(length = length[i], width = width[i], height = height[i])
  })]
  
  # 删除原始列
  dt[, c("length", "width", "height") := NULL]
  
  return(dt)
}
```
* `lapply(.I, function(i) {...})`：
	- 遍历每一行的行号 (1, 2, 3, ...)
	- 对每一行，用 `i` 取出该行的 `length[i]`, `width[i]`, `height[i]`
	- 组成一个命名向量
	- `.I` 是 data.table 中的特殊符号，表示**行号索引**
		- `dt[x > 5, .I]`  -----获取符合条件的行号