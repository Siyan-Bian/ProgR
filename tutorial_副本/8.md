## Ex1: 返回数据框随机两行
```r
twoRandomRows <- function(df) {
  checkmate::assertDataFrame(df, min.rows = 2)
  # your code
  set.seed(123)  #设置随机种子
  sample_index <- sample.int(nrow(df), 2)  #取数据框随机数行号
  df[sample_index,]  #返回行
}
```
* **sample.int(n, size)**: 从整数中抽样

## Ex2: 函数内调用函数
* 函数中调用无参数函数 **fun()**，调用成功返回 **TRUE**，否则 **FALSE**
```r
usedRNG <- function(fun) {
  checkmate::assertFunction(fun)
  # your code
  seed_before_exists <- exists(".Random.seed", where = .GlobalEnv, inherits = FALSE)
  
  if (seed_before_exists) {
    seed_before <- get(".Random.seed", envir = .GlobalEnv, inherits = FALSE)
  }
  
  # 2. 调用输入的函数 fun
  # 使用 tryCatch 来确保即使 fun() 报错，我们也能执行后续的检查
  tryCatch({
    fun()
  }, error = function(e) {
    # 忽略 fun() 内部的错误，但为了检测目的，我们继续
  })
  
  # 3. 记录函数执行后的 RNG 状态
  seed_after_exists <- exists(".Random.seed", where = .GlobalEnv, inherits = FALSE)
  
  # 4. 判断 RNG 是否被使用
  
  # 情况 A: 执行后 .Random.seed 不存在
  if (!seed_after_exists) {
    # 如果执行前也不存在，则没使用 RNG (因为使用 RNG 就会创建它)
    # 如果执行前存在，那么它被清除了，但在 R 的标准操作中，使用 RNG 是修改而不是清除
    # 在这个上下文中，我们假定标准使用 RNG 会创建/修改它。
    return(FALSE)
  } 
  
  # 情况 B: 执行后 .Random.seed 存在
  if (seed_after_exists) {
    # 如果执行前不存在，则说明 fun() 创建了它，即使用了 RNG
    if (!seed_before_exists) {
      return(TRUE)
    } else {
      # 如果执行前后都存在，比较它们的值
      seed_after <- get(".Random.seed", envir = .GlobalEnv, inherits = FALSE)
      
      # 检查前后两个向量是否完全相等 (TRUE 表示未改变，FALSE 表示已改变)
      # all.equal() 是比较复杂对象的推荐方法，如果相同返回 TRUE，否则返回描述差异的字符串
      # 这里的判断逻辑是：如果 all.equal 返回 TRUE (说明没有变化)，则返回 FALSE (说明没用 RNG)
      # 否则（all.equal 返回描述差异的字符串，说明有变化），则返回 TRUE (说明使用了 RNG)
      # 注意：我们必须使用 !isTRUE(...) 来正确处理 all.equal() 的返回值
      is_equal <- isTRUE(all.equal(seed_before, seed_after))
      
      return(!is_equal)
    }
  }
  
  # 默认返回 FALSE (理论上所有情况已被覆盖)
  return(FALSE)
}
```

## Ex3: 估计超立方体的体积
* 超立方体维度为 d，半径为 r
* 提示:
	* 在超立方体中生成 n 个点: `[-1,1]^d`
	* 计算有多少个点落在单位球体通过 `sum(x_i^2) <= 1`
	* 内部点的比例乘以方块的体积 `2^d` 就是球体的估计体积

```r
estimateSphereVolume <- function(d, n) {
  checkmate::assertCount(d, positive = TRUE)
  checkmate::assertCount(n, positive = TRUE)
  # your code
  # 1. 生成 n 个点在超立方体 [-1, 1]^d 中
  # 随机数矩阵：n 行 (点数) x d 列 (维度)
  # runif(N, min=-1, max=1) 在 [-1, 1] 之间生成 N 个均匀随机数
  # 我们需要生成 n * d 个数，然后将其排列成矩阵。
  points <- matrix(runif(n * d, min = -1, max = 1), nrow = n, ncol = d)
  
  # 2. 计算每个点的平方欧几里得距离 (即 x_1^2 + x_2^2 + ... + x_d^2)
  # 检查点是否落在单位球体 (半径为 1) 内： sum(x_i^2) <= 1
  
  # 2.1. 对矩阵中的每个元素进行平方
  squared_points <- points^2
  
  # 2.2. 对每一行（即每一个点）求和，得到距离的平方
  # rowSums() 是 R 中高效的行求和函数
  squared_distance <- rowSums(squared_points)
  
  # 2.3. 统计落入球体内的点数
  # (squared_distance <= 1) 返回一个逻辑向量 (TRUE/FALSE)
  # sum() 对逻辑向量求和时，会将 TRUE 视为 1，FALSE 视为 0
  points_inside <- sum(squared_distance <= 1)
  
  # 3. 计算超立方体的体积
  # 超立方体 [-1, 1]^d 的边长为 2，体积 V_cube = 2^d
  volume_cube <- 2^d
  
  # 4. 估计球体的体积 (蒙特卡罗积分公式)
  # V_sphere_estimate = (points_inside / n) * V_cube
  
  volume_sphere_estimate <- (points_inside / n) * volume_cube
  
  return(volume_sphere_estimate)
}
```

## Ex4: 轮盘赌局
```r
martingale <- function(bankroll, rounds.max) {
  checkmate::assertCount(bankroll)
  checkmate::assertCount(rounds.max)
    # your code
  # 1. 初始化变量
  
  # 存储每一步的资金变化
  bankroll_history <- c(bankroll) 
  
  # 当前资金余额
  current_bankroll <- bankroll 
  
  # 当前轮次的赌注。马丁格尔策略以 1 为基础赌注。
  current_bet <- 1 
  
  # 2. 主循环：模拟轮盘赌局
  # 循环将持续到达到最大轮次 (i) 或满足退出条件 (break)
  # 如果 rounds.max 为 0，直接跳过循环
  if (rounds.max > 0) {
    for (i in 1:rounds.max) {
      
      # 退出条件检查 A：资金不足以下注
      if (current_bankroll < current_bet) {
        # 玩家没有足够的钱来下当前轮次的赌注
        break 
      }
      
      # ----------------------------------------------------
      # 3. 模拟一轮赌局
      
      # 从 0 到 36 均匀抽取一个数字
      # sample(0:36, 1) 是一个标准的轮盘赌模拟
      result <- sample(0:36, 1) 
      
      # 确定输赢：
      # 获胜条件：结果是正偶数 (即 result > 0 且 result %% 2 == 0)
      # 输钱条件：结果是 0 或正奇数
      
      is_win <- (result > 0) && (result %% 2 == 0)  #条件判断用 &&
      
      # 4. 更新资金余额
      if (is_win) {
        # 获胜：赢得 current_bet (赔率 1:1)
        current_bankroll <- current_bankroll + current_bet
        
        # 记录资金变化
        bankroll_history <- c(bankroll_history, current_bankroll)
        
        # 策略规则：玩家一旦获胜，就退出（净赚 1 基础单位）
        break 
        
      } else {
        # 输钱：输掉 current_bet
        current_bankroll <- current_bankroll - current_bet
        
        # 记录资金变化
        bankroll_history <- c(bankroll_history, current_bankroll)
        
        # 策略规则：下一轮赌注加倍
        current_bet <- current_bet * 2
        
      }
    }
  }
  # 5. 返回资金历史记录
  return(bankroll_history)
}
```
