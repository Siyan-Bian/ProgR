## (a)题目：距离单位转换
##### 方法一
```r
ex01DistConversion <- function(distance, from = "km", to = "km") {
  assertNumeric(distance, any.missing = FALSE)
  # your code
  conversion <- c("km" = 1, "miles" = 1.609344, "nautical miles" = 1.852)
  assertChoice(from, names(conversion))
  assertChoice(to, names(conversion))

  round(distance * conversion[[from]] / conversion[[to]], 3)
}
```
* **输入验证:** assertNumeric(..., any.missing = FALSE)
	* 来自 `checkmate` 包的断言函数
	- 检查 `distance` 是否为数值型向量
	- `any.missing = FALSE` 确保没有 `NA` 值
	- 如果检查失败，会自动调用 `stop()` 抛出错误
- **命名向量:** conversion <- c(...)
	- 创建一个命名向量，存储每个单位相对于 km 的转换系数
	- `km = 1` 表示 1 km = 1 km（基准）
	- `` `nautical miles` = 1.852 `` 使用反引号，因为名称包含空格
- **输入验证：** assertChoice()
	- 来自 `checkmate` 包
	- 检查 `from` 和 `to` 是否在允许的选项中
	- `names(conversion)` 返回 `c("km", "miles", "nautical miles")`
	- 如果 `from` 或 `to` 不在这些选项中，会抛出错误
- **双方括号索引 `[[]]`**
	- `[[]]` 用于提取向量的**单个元素**
	- 对于命名向量，可以使用名称进行索引
	- 返回**未命名**的值（仅数值）
- **向量化运算**
	- **计算逻辑**：
		1. `distance * conversion[[from]]` → 将输入距离转换为 km
		2. `... / conversion[[to]]` → 将 km 转换为目标单位

##### 方法二(一般方法)
```r
ex01DistConversion <- function(distance, from = "km", to = "km") {
  # your code
  conversion_to_km <- c(   #将转换规则写成一个向量
    "km" = 1,
    "mile" = 1.609344,
    "nautical miles" = 1.852
  )
  
  distance_in_km <- distance * conversion_to_km[from]   #把距离统一为km
  result <- distance_in_km / conversion_to_km[to]   #把距离转换为to的单位
  result <- round((result), 3)   #round()取小数点后几位
  
  return(result)
}
```

## （b)题目：斐波那契数

##### 方法一(递归解法)
```r
ex02Fibonacci <- function(n) {
  # your code
  assertCount(n, tol = 0)
  if (n <= 0) return(0)
  if (n == 1) return(1)
  ex02Fibonacci(n - 1) + ex02Fibonacci(n - 2)
}
```
* **assertCount() 函数**
	* 来自 `checkmate` 包
	- `assertCount()` 检查输入是否为**非负整数**（count = 0, 1, 2, 3, ...）
	- `tol = 0` 表示容差为 0，必须是精确整数
- **递归 (Recursion)**
	- **基础情况**
		- 如果 n <= 0，返回0
		- 如果 n == 1，返回1
		- `return()` 立即退出函数并返回值
		- 基础情况防止无限递归
		- 顺序很重要：先检查最小的情况
	- **递归情况**
		- F(n) = F(n - 1) + F(n - 2)

##### 方法二: 黄金比例公式（Binet's Formula）
```r
ex02Fibonacci <- function(n) {
  # your code here
  assertCount(n, tol = 0)
  golden.ratio <- (1 + sqrt(5)) / 2
  round(golden.ratio ^ n / sqrt(5))
}
```
* ***Binet 公式**
	* **数学原理**：  
		$F(n)=\frac{ϕ^n−ψ^n}{\sqrt{5}}$
		
		其中：
		- $\phi = \frac{1 + \sqrt{5}}{2}$ (黄金比例，约 1.618)
		- $\psi = \frac{1 - \sqrt{5}}{2}$ (约 -0.618)
		- **简化版本**：
			- 当 n 增大时，$\psi^n$ 趋近于 0
			- 所以 $F(n) \approx \frac{\phi^n}{\sqrt{5}}$
			- 用 `round()` 处理浮点误差
- **sqrt():** 计算平方根公式
- **round():** 不带参数，四舍五入到整数，等价于 round(x, 0)