## (a)题目: 寻找函数的根
```r
ex01FindRoot <- function(fun, lower, upper) {
  # your code
  #输入验证
  assertFunction(fun)   #检查是否为函数类型
  assertNumber(lower, finite = TRUE)
  assertNumber(upper, finite = TRUE, lower = lower)#检查是否为数值类型，有限且>=下界
  
  #设置容差，决定了搜索的步长
  tolerance <- 0.001

  #生成搜索点的序列
  xvals <- seq(lower, upper, by = tolerance)
  #计算所有点的函数值
  fvals <- vapply(xvals, fun, 0)

  #找到第一个非负的位置
  crossover <- which(fvals >= 0)[[1]]
  #用索引提取向量元素
  return(xvals[[crossover]])
}
```
* **seq(from, to, by):** 生成等间隔序列
* **vapply(X, FUN, FUN.VALUE):**
	* X: 向量或列表
	* FUN: 应用的函数
	* FUN.VALUE: 返回值的模版
		* FUN.VALUE = 0 是 FUN.VALUE = numeric(1)的缩写，表示返回值是**单个数值**
	* 为什么使用vapply，而不是sapply?
		* vapply明确返回**numeric vector**，sapply可能返回**list**类型
* **which():** 返回满足条件的**索引(位置)**，返回值是整数向量


## (b)题目: 编写一个函数返回另一个函数，用于检查一个向量是否满足条件
```r
ex02VectorCondition <- function(threshold) {
  # your code
  #检查函数参数是否是标量数值
  assertNumber(threshold)
  
  #返回一个函数
  function(vect) {
	#检查函数参数是否是向量数值，无遗失值
    assertNumeric(vect, any.missing = FALSE)
    #检查输入向量中是否至少有一个元素大于threshold
    any(vect > threshold)   #threshold来自外层函数参数
  }
}
```
* **assertNumber()** 和 **assertNumeric()** 区分:
	* **assertNumber()** 只接受单个数值，必须是标量
	* **assertNumeric()** 接受数值向量
* **any(logical_vector)** 返回逻辑值 TRUE 或 FALSE


## (c)题目: 编写一个函数，从vectors列表中筛选出包含大于threshold的元素
```r
ex03VectorThreshold <- function(vectors, threshold) {
  # your code
  #检查输入vectors是否是一个列表，元素是否是数值类型下面再检查
  assertList(vectors, any.missing = FALSE)
  #筛选满足条件的元素
  Filter(ex02VectorCondition(threshold), vectors)
}
```
* **核心代码:**
	* **filter(f, x):**
		* **f:** 一个**判断函数**，返回 TRUE 或 FALSE
		* **x:** 一个列表或向量
		* 返回 **x** 中所有使 **v** 返回 **TRUE** 的元素
	* **ex02VectorCondition()的复用:**
		* 检查数值类型
		* 判断 **vect** 是否大于 **threshold**