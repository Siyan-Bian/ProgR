## (a)
```r
ex01ImputeTable <- function(data) {
  # your code
  assertDataTable(data)
  
  #找出所有传感器列
  sensorcols <- grep("^sensor[0-9]+", colnames(data), value = TRUE)
  
  #对每个传感器列进行缺失值填充
  data[, (sensorcols) := lapply(.SD, function(x) {
    nafill(x, fill = min(x, na.rm = TRUE))
  }), .SDcols = sensorcols][]
}
```
* `grep("^sensor[0-9]+", colnames(data), value = TRUE)`
	* `grep()` → 正则匹配列名
	- `"^sensor[0-9]+"` → 匹配以 "sensor" 开头 + 数字的列名
	- `value = TRUE` → 返回匹配的列名（而非索引）
	- **返回示例:** `sensorcols <- c("sensor01", "sensor02", "sensor03", "sensor04")`

* `data[, (sensorcols) := ..., .SDcols = sensorcols][]`
	* `(sensorcols) :=` → 对 `sensorcols` 中的列("sensor01", "sensor02", ...)进行**引用赋值**（修改原数据），而不是新增加一个名叫 sensorcols 的列
	* `.SDcols = sensorcols` → 指定 `.SD` 只包含传感器列
	* 最后的 `[]` → 返回修改后的 data.table（打印可见）

* `lapply(.SD, function(x) {...})`: 对 `.SD` 中的每一列应用函数
	* `min(x, na.rm = TRUE)` → 计算该列的最小值（忽略 NA）
	* `nafill(x, fill = ...)` → 用该最小值填充所有 NA

* `.SD` = **"Subset of Data"**（数据子集）
```r
library(data.table)

dt <- data.table(
  x = 1:5,
  y = 6:10,
  z = 11:15
)

# .SD 包含所有列
dt[, .SD]
#    x  y  z
# 1: 1  6 11
# 2: 2  7 12
# 3: 3  8 13
# 4: 4  9 14
# 5: 5 10 15

# .SD 和原数据一样（没有分组时）
identical(dt[, .SD], dt)  # TRUE

#用 `.SDcols` 指定列
# 只包含 x 和 y 列
dt[, .SD, .SDcols = c("x", "y")]
#    x  y
# 1: 1  6
# 2: 2  7
# 3: 3  8
# 4: 4  9
# 5: 5 10

# 用正则匹配列名
dt[, .SD, .SDcols = patterns("^[xy]")]
#    x  y
# 1: 1  6
# 2: 2  7
# ...
```


## (b)
```r
ex02ModelTable <- function(data) {
  # your code
  #参数检查
  assertDataTable(data)
  
  #数据清理和填补
  data <- ex01ImputeTable(ex02CleanTable(data))

  #按机器分组拟合模型
  data[, .(model = list(lm(quality ~ ., .SD))), by = "machine"]
}
```
* `data <- ex01ImputeTable(ex02CleanTable(data))`
	* `ex02CleanTable(data)` --- 删除缺失值≥50%的列
	* `ex01ImputeTable(...)` --- 填补剩余列的缺失值
	* 结果：干净、无缺失值的数据

* `data[, .(model = list(lm(quality ~ ., .SD))), by = "machine"]`
	* `by = "machine"`: 按机器分组，每个机器处理一次
	* `.SD`: 当前机器的所有数据，包括 `quality` 和所有传感器列
	* `lm(quality ~ ., .SD)`: 
		* `quality ~.` : 用 `quality` 作为因变量，其他所有列作为自变量
			* `.` 表示"除了 `quality` 之外的所有列"
		* `.SD` : 数据来源
		* **关键：** `lm()` 会**自动忽略**公式左边的 `quality` 列，只用右边的其他列作为自变量
		* `list(lm(...))`: 把 `lm` 对象包装成 list，因为 `model` 列是 list-column
	* `.(model = ...)`: 返回包含 `machine` 和 `model` 两列的 data.table