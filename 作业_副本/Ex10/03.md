## (a)将传感器数据收集到列表列
* **目标**: 将所有传感器列合并成一个 `list` 列，每行包含一个**命名的数值向量**，只保留非 NA 的传感器值

```r
ex01ListTable <- function(data) {
  # your code
  #检查参数
  assertDataTable(data)
  
  #包装成 list 并添加到原始 data.table，选择需要的列
  data[, sensor := list(list(c(na.omit(unlist(.SD))))),
    .SDcols = patterns("^sensor[0-9]+"), by = .I][,
    c("machine", "quality", "sensor"), with = FALSE
  ]
}
```
* `patterns("^sensor[0-9]+", by = .I)`: 匹配所有以 `sensor` 开头后跟数字的列
	* `by = .I`: 对每一行分别处理
		* `.I` 是 data.table 的特殊符号，表示行号
* `unlist(.SD)`: 返回一个命名向量
```r
# 对于第 1 行的 .SD：
#   sensor01  sensor02  sensor03  sensor04
#      23       28.6      -23       NA

unlist(.SD)
# sensor01 sensor02 sensor03 sensor04 
#     23.0     28.6    -23.0       NA
# 返回一个命名向量
```
* `na.omit(unlist(.SD))`: 移除 **NA** 值
```r
na.omit(unlist(.SD))
# sensor01 sensor02 sensor03 
#     23.0     28.6    -23.0
# 移除了 NA 值，保留了名称
```
* `c(na.omit(unlist(.SD)))`：确保结果是向量 (在某些情况下 na.omit 可能返回特殊类)
* `list(c(na.omit(unlist(.SD))))`：将向量包装在 list 中
* `[, c("machine", "quality", "sensor"), with = FALSE]`：
	* 只保留 `machine`, `quality`, `sensor` 三列
	* `with = FALSE` 表示使用字符向量选择列



## (b)
```r
ex02CleanTable <- function(data) {
  # your code
  assertDataTable(data)
  
  keep <- data[,
    as.list(colMeans(is.na(.SD))),  #计算每列的NA比例，转换为list
    by = "machine",  #按机器分组
    .SDcols = patterns("^sensor[0-9]+")  #只选择传感器列
  ][, machine := NULL  #删除 machine 列，因为下一步要取最大值，machine 列不需要
  ][, colnames(.SD)[vapply(.SD, max, numeric(1)) < 0.5]
  ]  # 找出每列在所有机器中的最大 NA 比例，筛选 < 0.5 的列
  data[, c("machine", "quality", keep), with = FALSE]  #返回筛选后的数据
}
```
* `vapply(.SD, max, numeric(1))`: 
	* 对每一列应用 `max()` 函数
	* 返回每列在所有机器中的最大 NA 比例
	* 筛选最大 NA 比例 < 0.5 的列
* `colnames(.SD)[...]`: 用逻辑向量筛选列名
* `data[, c("machine", "quality", keep), with = FALSE]`
	* 保留 `machine` 和 `quality` 列
	- 加上筛选出的传感器列（`keep`）
	- `with = FALSE` 表示 `c("machine", "quality", keep)` 是列名向量，不是表达式