## 要求
* **输入验证**：检查 `lst` 是否为列表，每个元素是否为命名列表，值是否为数值标量
- **核心逻辑**：使用 `rbindlist` 转换，用 `nafill` 或 `setnafill` 处理缺失值

## 答案
```r
ex01List2DT <- function(lst) {
  #参数检查
  assertList(lst)
  
  #对列表的每个元素应用函数
  lapply(lst, function(l) {
    assertList(l, names = "unique") #names用于检查列表元素的名称
    lapply(l, assertNumber)  #检查每个值都是数值
  })

  result <- rbindlist(lst, use.names = TRUE, fill = TRUE)
  setnafill(result, fill = 0)[]  #返回修改后的对象
}
```
* assertList(x, names = ...):
	* names = "unnames": 无名称，列表没有名称时通过检查 (x <- list(1, 2, 3))
	* names = "names": 有名称，列表所有元素都有名称时通过检查 (x <- list(a = 1, b = 2))
* **rbindlist():**
	* use.names = TRUE: 按列名匹配（默认值）
		* use.names = FALSE: 按位置匹配
	* fill = TRUE: 缺失列用 **NA** 填充
```r
# use.names = TRUE（默认）
rbindlist(lst, use.names = TRUE) 
#    a b 
# 1: 1 2 
# 2: 4 3 ← 正确！按名称匹配

# use.names = FALSE 
rbindlist(lst, use.names = FALSE) 
#    a b 
# 1: 1 2 
# 2: 3 4 ← 错误！按位置匹配，b 和 a 对调了
```
* **setnafill():** 用于填充NA值，返回修改后的对象，但是不可见
	* fill = 0: 把所有 **NA** 值替换为 0
	* `[]`: **强制打印**并返回对象
	* 为什么需要setnafill? -----因为rbindlist(..., fill = TRUE)会产生 **NA** 值