## 问题要求
* 编写一个函数，对 `data.table` 按以下规则排序：
	1. **主要排序**：按 `sensorXX` 列中 NA 的数量，**降序**排列
	2. **次要排序**：如果 NA 数量相同，按 `quality` **降序**排列

## 答案代码
```r
ex01SortTable <- function(data) {
  # your code
  #参数检查
  assertDataTable(data)

  #计算每行的 NA 数量
  data[, missings := rowSums(is.na(.SD)), .SDcols = patterns("^sensor")]

  #排序并删除临时列
  setorderv(data, c("missings", "quality"), order = -1)[, missings := NULL][]
}
```
* **rowSums(is.na(...))**: 计算 **NA** 数量
	* `is.na()`: 返回逻辑矩阵
	* `rowSums()`: 把 TRUE 当作 1 求和
* **.SDcols = patterns("^sensor")**: 正则表达式选择特定列
	* patterns(pattern1, pattern2, ...): 返回通过正则表达式匹配到的列名，可以直接用于 `.SDcols` 参数
	* 正则表达式 `"^sensor"`: 
		* `^`: 匹配字符串的开头
		* `sensor`: 字面匹配 "sensor" 这几个字符![[截屏2026-01-13 17.36.52.png]]
* `:=` :引用修改
	* 创建新列：`dt[, new_col := value]`
	* 删除列：`dt[, col := NULL]`
	* 修改多列：`dt[, := (col1 = val1, col2 = val2)]
* **setorderv(dt, cols, order = 1):** 按指定列排序
	* `c("missings", "quality")`: 先按 missings 排序，再按 quality 排序
	* `order = -1`: 降序排列
		* 1 或 c(1, 1): 全部升序
		* -1 或 c(-1, -1): 全部降序
		* c(1, -1): 第一列升序，第二列降序
	* `[, missings := NULL]`: 删除临时列 missings
	* `[]`: 强制返回结果 (触发打印)