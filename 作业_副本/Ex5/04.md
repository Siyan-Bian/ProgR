## (a)题目: 判断井字棋胜负
##### 游戏规则回顾
* **重力井字棋（Gravity Tic Tac Toe）**
	- 3×3 的棋盘
	- 列名：A, B, C
	- 行号：1, 2, 3（1在上，3在下）
	- 玩家选择列，棋子自动落到该列最底部的空位
##### 函数需求
* **函数名：** `ex01Winner(position)`´
* **输入参数：**
	- `position`：一个 3×3 的字符矩阵
	    - 合法值：`"X"`、`"O"`、`NA`
	    - 代表当前棋盘状态
##### 特殊说明
* **NA的类型:**
	* is.logical(NA) ---> TRUE
	* is.character(NA) ---> FALSE
	* is.logical(NA_character_) ---> FALSE
	* is.character(NA_character_) ---> TRUE

```r
x01Winner <- function(position) {
  # your code
  #参数验证
  assertMatrix(position, mode = "character", nrows = 3, ncols = 3)
  assertSubset(position, c("X", "O", NA))  #NA作为集合的一个元素可以被检查                                              
  
  #定义辅助函数（检查一条线(行/列/对角线)是否被某个玩家占据）
  getWinner <- function(spaces) {  #输入spaces(长度为3的向量)，代表一条线上的3个位置
    if (identical(spaces, rep("X", 3))) {  #如果这条线全是X
      "X"
    } else if (identical(spaces, rep("O", 3))) {  #如果这条线全是O
      "O"
    } else {  #其他情况
      NA_character_
    }
  }
  
  #检查所有可能的获胜线
  winners <- c(
    apply(position, 1, getWinner),  #检查所有行
    apply(position, 2, getWinner),  #检查所有列
    getWinner(diag(position)),  #检查主对角线
    getWinner(diag(position[, 3:1]))  #检查副对角线
  )
  
  #处理结果
  winners <- unique(winners[!is.na(winners)])  #提取不为NA的逻辑索引，最后去重
  if (length(winners) > 1) {  #检查双赢（非法状态）
    stop("Bad starting position")
  }
  if (length(winners)) {  #作为条件，数值会被转换为逻辑值(0 --> FALSE; 非0 --> TRUE)
    return(winners)  #即 length(winners) == 1时返回获胜者
  }
  if (!any(is.na(position))) {  #检查是否平局
    return("")
  }
  NA  #默认返回NA，游戏未结束，游戏继续
}
```
* **identical():** 检查两个对象是否完全相同
	* 与 == 的区别:
		* c(1, 2, 3) == c(1, 2, 3) ---> TRUE TRUE TRUE
		* identical(c(1, 2, 3), c(1, 2, 3)) ---> TRUE
		* 关键区别: 处理 **NA** 值
			* c(NA, 1, 2) == c(NA, 1, 2) ---> NA TRUE TRUE
			* identical(c(NA, 1, 2), c(NA, 1, 2)) ---> TRUE
* **rep():** 重复元素生成向量
	* 基本用法:
		* rep(x, times): 重复 x 整体 times 次
		* rep(x, each): 重复 x 每个元素 each 次
		* rep(x, length.out): 重复到指定长度
* **apply(X, MARGIN, FUN):**
	* **MARGIN:** 1(行)，2(列)，c(1, 2)(每个元素)
* **diag():** 提取或创建对角矩阵
	* 用法一：**diag(matrix)** 提取主对角线元素
	* 用法二：**diag(vector)** 用向量创建对角矩阵
	* 这里用到了`position[, 3:1]`提取副对角线（反转列顺序，第三列和第一列交换， 第二列保持不变，现在提取的主对角线就是原来的副对角线）
* **any():** 检查是否至少有一个TRUE
	* 这里 is.na(position) 生成一个逻辑矩阵
	* any(is.na(position)) 检查逻辑矩阵中是否有空位
	* !any(is.na(position)) 检查是否没有空位
	* 棋盘已满（没有空位，没有分出胜负）---> 平局


## 执行一步棋

##### 函数定义
* **参数：**
	- `column`: 字符串，列名"A", "B", "C"
	- `position`：3×3 字符矩阵，当前棋盘状态
* **功能：** 在指定列落子，返回新棋盘状态
* **返回值：** 新的 3×3 字符矩阵

##### 重力规则详解
* **合法的列：**
```r
# 列 A 的状态
c(NA, NA, "X")    # ✓ 棋子在底部
c(NA, "X", "O")   # ✓ 棋子连续
c("X", "O", "X")  # ✓ 列已满

# 非法的列
c(NA, "X", NA)    # ✗ 中间有棋子，底部是空的
c("X", NA, "O")   # ✗ 有空隙
```

```r
ex02MoveStringToCoordinate <- function(column, position) {
  # your code
  #验证参数
  assertMatrix(position, mode = "character", nrows = 3, ncols = 3)
  assertSubset(position, c("X", "O", NA))
  assertString(column)  #检查是否为单个字符串
  
  #列名转换为列索引
  col <- match(column, LETTERS[1:3])
  
  #自定义错误条件
  if (is.na(col)) {
    stop(errorCondition(sprintf("Invalid move: %s.", column), class = "InvalidMoveError"))
  }
  
  #查找落子行位置
  row <- max(c(which(is.na(position[, col])), 0))
  if (row == 0) {
    stop(errorCondition(sprintf("Column %s already full.", column), class = "InvalidMoveError"))
  }
  c(row, col)
}
```
* **match():** 转换
	* 示例:
		* match("A", LETTERS[1:3]) ---> 1
		* match("B", LETTERS[1:3]) ---> 2
		* match("D", LETTERS[1:3]) ---> NA
	* **LETTERS:** 内置常量，包含26个大写字母
* **errorCondition(message, class):**
	* **message:** 错误消息
	* **class:** 错误类别
* **sprintf(fmt, ...):** 格式化字符串
	* **fmt:** 格式字符串
		* %s: 字符串   **例如:** `sprintf("Hello %s", "World")` → "Hello World"
		* %d: 整数
		* %f: 浮点数
	* ...: 要插入的值
* **which(x):** 返回 TRUE 元素的索引位置
	* **x:** 逻辑向量
	* 示例:
```r
x <- c(FALSE, TRUE, FALSE, TRUE, TRUE)
which(x)
# [1] 2 4 5  <- TRUE 的位置

# 用于矩阵
is.na(c(NA, NA, "X"))
# [1]  TRUE  TRUE FALSE

which(is.na(c(NA, NA, "X")))
# [1] 1 2  <- NA 的位置
```
* **核心代码:** row <- max(c(which(is.na(position[, col])), 0))
	* position[, col] : 提取列
	* which(is,na(position[, col])): 找出所有 NA 的位置
	* 如果列已满（没有NA），which()返回空向量，max()会警告，所以添加 0 作为默认值
	* 为什么取最大值? ---因为要找最下面的空位
		* 示例: column <- c(NA, NA, "X") --- NA的位置: 1, 2 --- 最大值: 2 --- 落子在第2行