## (a)从字符串中提取 URL，并将其拆分为协议、域名和路径三个部分

```r
ex01UrlFinder <- function(input) {
  # your code
  #参数验证
  assertString(input)
  #rx <- "(?<![[:alpha:]])(https?)://([[:alnum:]][-[:alnum:]]*(?:\\.[[:alnum:]][-[:alnum:]]*)+)/([-a-z[:digit:]/]*)"

  #构造正则表达式
  pattern <- paste0(
    "(?<![[:alpha:]])(?<protocol>https?)://",
    "(?<domainname>[[:alpha:]][-[:alpha:]]*(?:\\.[[:alpha:]][-[:alpha:]]*)+)/",
    "(?<path>[a-z[:digit:]/-]*)"
  )

  #执行匹配
  matches <- regmatches(input, gregexec(pattern, input, perl = TRUE, ignore.case = TRUE))[[1]]

  #处理空结果
  if (!length(matches)) {
	#返回空数据框
    return(data.frame(protocol = character(0), domainname = character(0), path = character(0)))
  }

  #转换为数据框
  as.data.frame(t(matches[-1, ]))  #移除第一行并转置
}
```
* **正则表达式拆解分析：**
	* **第一部分**
		* `(?<![[:alpha:]])`: 负向后顾断言
			* `(?<!pattern)`：当前位置**之前**不能匹配 `pattern`
			* `[[:alpha:]]`：POSIX 字符类：匹配任何字母
				* 等价于：`[A-Za-z]`
		* `(?<protocol>https?)`：命名捕获组
			* `(?<name>pattern)`：捕获匹配的内容，并命名为 `name`
			* `http`: 字面匹配 "http"
			* `s?`: 's' 出现 0 次或 1 次
		* `://`:  字面匹配字符 "://"
	* **第二部分**
		* `(?<domainname>...)`: 命名捕获组
		* `[[:alpha:]]`: 匹配一个字母，也就是域名以字母开头
		* `[-[:alpha:]]*`: 后续字母或连字符（可选零次或多次）
		* `(?:...)+`: 重复1次或多次
		* `\\.`: 点号
		* `[[:alpha:]]`: 下一部分的第1个字母
		* `[-[:alpha:]]*`: 下一部分的后续字符
		* `/`：匹配字面字符 '/'
	* **第三部分**
		* `(?<path>...)`: 命名捕获组
		* `[a-z[:digit:]/-]*`: 零次或多次的路径字符
			* `a-z`: 小写字母 a 到 z
			* `[:digit:]`: 数字 0-9
			* `/`：斜杠
			* `-`：连字符
		* 示例：
```r
paths <- c(
  "path",           # ✓ 小写字母
  "path/to/file",   # ✓ 字母 + 斜杠
  "path-123",       # ✓ 字母 + 连字符 + 数字
  "Path",           # ✗ 有大写字母
  "path?query",     # ✗ 有特殊字符
  ""                # ✓ 空路径（* 允许0次）
)

grepl("^[a-z[:digit:]/-]*$", paths)
# [1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE
```
* **完整正则表达式示例**
```r
文本: "Visit https://example.com/path/to/file and http://test.org/"
            ↑                              ↑   ↑                  ↑
          位置7                          位置39 位置44          位置61

第1个匹配 (位置7-38):
  协议: "https"
  域名: "example.com"
  路径: "path/to/file"

第2个匹配 (位置44-60):
  协议: "http"
  域名: "test.org"
  路径: ""
```
* **gregexec(pattern, text, perl = TRUE, ignore.case = FALSE):
	* **perl = TRUE:** 使用 Perl 兼容正则（否则负向后顾断言以及命名捕获组会报错）
	* **ignore.case = FALSE:** 忽略大小写
	* 和 **gregexpr()** 的区别: 
		* gregexec() 返回一个**矩阵**
		* gregexpr() 返回一个**向量**
* **regmatches():** 根据匹配位置提取实际文本
* **t():** 转置
	* 为什么需要转置?
```r
# 转置前：3行×N列
matches[-1, ]
#      [,1]           [,2]
# [1,] "https"        "http"
# [2,] "example.com"  "test.org"
# [3,] "path"         "file"

# 转置后：N行×3列
t(matches[-1, ])
#      [,1]          [,2]           [,3]
# [1,] "https"       "example.com"  "path"
# [2,] "http"        "test.org"     "file"
```