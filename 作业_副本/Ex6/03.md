## (a) 将多种日期格式统一转换为 `YYYY-MM-DD` 格式

```r
ex01DateConvert <- function(strings, century.cutoff) {
  # your code
  #参数验证
  assertCharacter(strings, any.missing = FALSE)
  assertInt(century.cutoff, lower = 0, upper = 99, tol = 0)

  #定义日期格式正则表达式
  patterns.dateformats <- c(
    "(?<year>\\d{4}|\\d{2})-(?<month>\\d{2})-(?<day>\\d{2})",
    "(?<day>\\d{2})\\.(?<month>\\d{2})\\.(?<year>\\d{4}|\\d{2})",
    "(?<month>\\d{2})/(?<day>\\d{2})/(?<year>\\d{4}|\\d{2})"
  )

  #循环处理每种格式
  for (pattern in patterns.dateformats) {
	#提取所有匹配，带捕获组的全局匹配
    matches <- regmatches(strings, gregexec(pattern, strings, perl = TRUE))
	#标准化每个匹配
    matches.normalized <- lapply(matches, function(m) { #对每个字符串的匹配结果应用转换函数
      if (!length(m)) return(character(0))  #空匹配检查
      days <- m["day", ]
      months <- m["month", ]
      years <- m["year", ]
      years <- ifelse(nchar(years) == 2,  #如果年份是2位数字
        ifelse(as.numeric(years) > century.cutoff,
          paste0("19", years),
          paste0("20", years)
        ),
        years  #已经是4位，不变
      )
      #格式化输出（%s代表字符串）
      sprintf("%s-%s-%s", years, months, days)
    })
	
	#替换原文本
    regmatches(strings, gregexpr(pattern, strings, perl = TRUE)) <- matches.normalized
  }

  strings
}
```
##### **正则表达式拆解分析:**
* **模式1：YYYY-MM-DD 和 YY-MM-DD**
```r
(?<year>\\d{4}|\\d{2})  -  (?<month>\\d{2})  -  (?<day>\\d{2})
        ↓               ↓         ↓            ↓        ↓
    捕获年份          字面   捕获月份      字面   捕获日期
  (4位或2位数字)     连字符   (2位数字)    连字符  (2位数字)
```
* `(?<name>pattern)` - 命名捕获组
	* **语法:** (?<组名>正则表达式)
* 为什么 YYYY-MM-DD 要放在第一个？
```r
# 假设先处理 DD.MM.YYYY
strings <- "Meeting on 2023-12-01 and 01.12.2023"

# 第一轮：转换 DD.MM.YYYY
# "01.12.2023" → "2023-12-01"
strings <- "Meeting on 2023-12-01 and 2023-12-01"

# 第二轮：转换 YYYY-MM-DD
# 但这两个日期已经是正确格式！
# 如果模式是 \\d{2}-\\d{2}-\\d{2}，会匹配 "23-12-01"
# 导致重复处理！
```
* **模式2：DD.MM.YYYY 和 DD.MM.YY**
```r
(?<day>\\d{2})  \\.  (?<month>\\d{2})  \\.  (?<year>\\d{4}|\\d{2})
      ↓          ↓          ↓            ↓           ↓
  捕获日期     字面点   捕获月份       字面点    捕获年份
  (2位数字)            (2位数字)               (4位或2位)
```
* `\\.` - 转义的点
* **模式3：MM/DD/YYYY 和 MM/DD/YY**
```r
(?<month>\\d{2})  /  (?<day>\\d{2})  /  (?<year>\\d{4}|\\d{2})
       ↓          ↓        ↓          ↓          ↓
   捕获月份     字面     捕获日期   字面    捕获年份
   (2位数字)    斜杠    (2位数字)  斜杠   (4位或2位)
```
* `/` 在正则表达式中**不是元字符**，所以不需要转义


## (b) 验证字符串形式的数学等式是否成立

* example.equations <- c("3 + 4 - 10 = -3", "3+5 -2 + 2 =12", "9 - 2 + 4 = 0",
                       "2 =5", "3-4 = 5 - 6", "-30 + 40 = 10")
* 应该返回: c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE)

```r
ex02EquationCheck <- function(equations) {
  # your code
  #参数验证
  assertCharacter(equations, any.missing = FALSE)

  #移除空格（有空格时分割变复杂）
  equations <- gsub(" ", "", equations)

  #定义计算函数
  evalEqnPart <- function(eqn.part) {
    pattern <- "[+-]?[^+-]+"
    numbers <- regmatches(eqn.part, gregexpr(pattern, eqn.part))[[1]]
    sum(as.numeric(numbers))
  }

  #处理每个等式
  vapply(strsplit(equations, "="), function(eqn.parts) {
    lhs <- evalEqnPart(eqn.parts[[1]])  #计算左边
    rhs <- evalEqnPart(eqn.parts[[2]])  #计算右边
    abs(lhs - rhs) < 1e-8  #浮点数比较
  }, logical(1))  #返回长度为1的逻辑向量，TRUE或FALSE
}

```
* **gsub()**: 可以删除或替换**任何位置**的内容，这里用""替换空格
	* 处理位置: 首、尾、中间任何地方
	* 和 **trimws()** 的区别: 
		* trimws() 只删除字符串**首尾**的空格，功能固定，专门去空格
* **正则表达式拆解分析:**
	* `[+-]`: 括号内表示可选的符号，匹配 + 或 -
	* `?`:  量词，0次或1次
	* `[^+-]+`: 否定字符类，匹配任何不是 + 或 - 的字符，在 [ ] 内部，^ 表示否定
	* `+`：量词，1次或多次
* **完整匹配示例:**
```r
text <- "3+4-10"
pattern <- "[+-]?[^+-]+"

matches <- regmatches(text, gregexpr(pattern, text))[[1]]
matches
# [1] "3"   "+4"  "-10"
```
* **vapply(X, FUN, FUN.VALUE):** 
	* **FUN.VALUE:** 返回值模版
* **strsplit(X, "..."):** 分割函数
	* "...": 分割符号
* **浮点数比较:**
	* 直接使用 lhs == rhs  可能因误差而失败
	* 正确使用 abs(lhs - rhs) < 1e-8  允许小误差
	* 1e-8含义: 1e-8 = 0.00000001  千万分之一
* **abs():** 容差计算