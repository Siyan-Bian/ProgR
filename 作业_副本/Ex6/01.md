## (a) 将非负整数填充到相同长度，不足位数前面补0
* **参数：** `numbers` - 非负整数的数值向量
* **返回值：** 字符向量，所有元素长度相同

```r
ex01PadNumbers <- function(numbers) {
  # your code
  assertIntegerish(numbers, lower = 0, tol = 0)

  #处理空向量（如果输入为空向量，返回空字符向量）
  if (!length(numbers)) return(character(0))
  #计算最大数字
  max.number <- max(numbers, 1, na.rm = TRUE)
  #计算最大位数
  max.digits <- nchar(max.number)
  
  ifelse(is.na(numbers),  #判断是否 NA
    NA_character_,  #对于 NA 的数字
    sprintf(paste0("%0", max.digits, "d"), numbers)  #对于非 NA 的数字
  )
}
```
* **assertIntegerish(X, lower = -Inf, upper = Inf, tol = sqrt(.Machine$double.eps)):**
	* **X:** 要检查的对象
	* **lower:** 最小值
		* lower = 0: 确保所有数字 $\geq$ 0
	* **upper:** 最大值
	* **tol:** 容差（判断是否为整数）
		* tol = 0: 确保为整数，任何小数部分都不行
	* 和 **assertInt()** 的区别:
		* assertInt() 只接受真正的整数类型(1L, 2, 10, ...)
		* assertIntegerish() 可以接受浮点型(**小数位为0**) (1L, 1.0, 1.000, ...)
* **max():**
	* **`na.rm = TRUE`** - 忽略 NA 值
	* **添加 `1`** - 避免 `-Inf` 警告
```r
#为什么添加 `1`？
#问题: 如果所有数字都是 NA
numbers <- c(NA, NA, NA)

# 不加 1 的情况
max(numbers, na.rm = TRUE)
# Warning: no non-missing arguments to max; returning -Inf
# [1] -Inf

nchar(-Inf)
# [1] 4  # "-Inf" 有4个字符 ✗

# 加 1 的情况
max(numbers, 1, na.rm = TRUE)
# [1] 1  # 没有警告 ✓

nchar(1)
# [1] 1  # 正确 ✓
```
* **nchar(x):** 计算字符串长度
	* **x:** 可以是字符或者数值 (数值会先转换为字符!!!)
```r
nchar("hello")   # 5
nchar("你好")    # 2
nchar(123)       # 3  # 数值会先转为字符 "123"
nchar(1000)      # 4
nchar(0)         # 1
```
* **ifelse(test, yes, no):** 向量化的条件选择
	* **示例:**
```r
x <- c(1, 2, 3, 4, 5)
ifelse(x > 3, "大", "小")
# [1] "小" "小" "小" "大" "大"

ifelse(c(TRUE, FALSE, TRUE), "Yes", "No")
# [1] "Yes" "No"  "Yes"
```
* **paste0():** 将多个字符串拼接在一起（无分隔符）
	* **示例:**
		* paste0("Hello", " ", "World")  ---> "Hello World"
		* paste0("a", "b", "c")  ---> "abc"
		* 假设 `max.digits = 3`
			* paste0("%0", 3, "d") ---> "%03d"
	* **和paste()的区别:**
		* paste("%0", 3, "d") ---> "%0 3 d" **有空格**
		* paste0("%0", 3, "d") ---> "%03d" **没有空格**
* **sprintf(fmt, ...):**
	* **fmt:** 格式字符串
	* **...:** 要格式化的值
* **格式字符串 `"%03d"` 拆解：**
```r
%  0  3  d
│  │  │  │
│  │  │  └─ d = decimal（十进制整数）
│  │  └──── 3 = 总宽度为3个字符
│  └─────── 0 = 用0填充（而非空格）
└────────── % = 格式符开始标记
```


## (b) 统一填充文件名中的数字

```r
ex02PadFiles <- function(filenames) {
  # your code
  #参数验证
  assertCharacter(filenames, any.missing = FALSE)

  #定义正则表达式模式
  pattern <- "[[:digit:]]+"  # or: "[0-9]+"

  #在文件名中查找数字
  matches <- regexpr(pattern, filenames)

  #提取匹配的数字字符串
  numbers <- regmatches(filenames, matches)

  #将数字字符串转为数值并填充，调用 `ex01PadNumbers` 填充
  numbers.padded <- ex01PadNumbers(as.numeric(numbers))
  
  #替换原文件名中的数字
  regmatches(filenames, matches) <- numbers.padded

  filenames
}
```
* **`[[:digit:]]+` 详解**
	* **`[[:digit:]]`:** 字符类，匹配任意一个数字（0-9）
	* **+:** 量词，表示"一个或多个"
	* **等价写法：**
		* `[[0-9]]+: 直接指定范围
	* **为什么用 `+` 而不是 `*`？**
		* `+`: 一个或多个数字
		* `*`: 零个或多个数字
* **regexpr():** 在每个字符串中查找**第一个**匹配的位置和长度
	* 返回一个整数向量，包含两个属性：
		* **值本身：** 匹配的起始位置（-1表示未找到）
		* **`match.length` 属性：** 匹配的长度
	* **示例:**
```r
filenames <- c("file1.pdf", "file10.pdf", "help.txt", "100-music.pdf")
matches <- regexpr("[[:digit:]]+", filenames)
matches
# [1]  5  5 -1  1
# attr(,"match.length")
# [1]  1  2 -1  3
# attr(,"index.type")
# [1] "chars"
# attr(,"useBytes")
# [1] TRUE
```
* **regmatches(x, m):** 根据 `regexpr()` 的结果提取匹配的子字符串
	* **x:** 原始字符串向量
	* **m:** regexpr()返回的匹配信息（位置+长度）
	* **示例:**
```r
filenames <- c("file1.pdf", "file10.pdf", "help.txt", "100-music.pdf")
matches <- regexpr("[[:digit:]]+", filenames)

numbers <- regmatches(filenames, matches)
numbers
# [1] "1"   "10"  "100"
#          ↑
#    注意："help.txt"没有匹配，所以结果中没有对应元素！
```
* **`regmatches(x, m)` 赋值功能：** 将匹配的部分替换为新字符串
	* **x:** 要修改的原始向量
	* **m:** 匹配信息（位置+长度）