## (a)统计每个月的唯一用户数
```r
ex01MonthlyUsers <- function(ledger, year) {
  # your code
  assertDataTable(ledger)
  assertInt(year, tol = 1e - 100)
  
  # 确定用户
  ledger[, user := ifelse(src == "DEPOSIT", dst, src)]
  
  # 筛选年份 + 分组统计
  ret <- ledger[yr == year,   # 只看指定年份
				.(users = length(unique(user))),  # 去重后计数 = 唯一用户数
                keyby = .(month = mth)][J(1:12)]  # 按月分组，并排序
                
  # 填充 NA 为 0 (如果某月没数据，结果会是 NA)
  setnafill(ret, fill = 0, cols = "users")[]
}
```
* **确定用户规则：**
	- 如果 `src == "DEPOSIT"` → 用户是 `dst`（存款人）
	- 否则 → 用户是 `src`（转账发起人）
- **J():** 是 data.table 中用于**按 key 查找**的函数，所以前面必须用 `keyby` 设置 key
	- **J(1: 12)** 等价于 **data.table(month = 1:12)**
- **keyby:** 排序后输出
	- 和 **by** 的区别: by 按出现顺序输出
	- **z.B:**
```r
dt <- data.table(
  month = c(3, 1, 2, 1),
  value = c(10, 20, 30, 40)
)

# by：按出现顺序
dt[, .(total = sum(value)), by = month]
#    month total
# 1:     3    10   ← 3 先出现
# 2:     1    60
# 3:     2    30

# keyby：排序后输出
dt[, .(total = sum(value)), keyby = month]
#    month total
# 1:     1    60   ← 自动排序
# 2:     2    30
# 3:     3    10
```


## (b)
```r
ex02Transactions <- function(ledger, year, month) {
  # your code
  assertDataTable(ledger)
  assertInt(year)
  assertInt(month, lower = 1, upper = 12)
  
  # 月初往前推9天（需要前9天数据算滚动平均）
  begin <- as.Date(ISOdate(year, month, 1)) - 9
  # 月末最后一天
  end <- if(month == 12) {
    as.Date(ISOdate(year, month, 31))
  } else (
    as.Date(ISOdate(year, month + 1, 1)) - 1
  )
  
  # 创建日期序列模板
  dseq <- seq(begin, end, by = "day")
  template <- data.table(yr = year(dseq), mth = month(dseq), day = mday(dseq))
  
  # 用 template 左连接 ledger，没有交易的日期会得到 NA
  res <- ledger[template, on = c("yr", "mth", "day")]
  
  # 统计每日交易数
  res <- res[, .(transactions = sum(!is.na(amt))), by = c("yr", "mth", "day")]
  
  # 计算10天滚动平均
  # 每个位置 = 该位置及前9天（共10天）的平均值
  # 前9行没有足够数据，会是 NA
  res[, transactions := frollmean(res$transactions, 10)]
  
  # 去掉前9行
  res[-(1:9)]  # 前9行是"上个月"的数据，只是用来算滚动平均的，不需要输出
}

```