## (a)排序
```r
ex01SortLedger <- function(ledger) {
  # your code
  assertDataTable(ledger)
  ledger[order(yr, mth, day)]
}
```


## (b)筛选在指定日期之前的日期
```r
ex02TrimLedger <- function(ledger, year, month, day) {
  # your code
  # 参数验证
  assertDataTable(ledger)
  assertInt(year)
  assertInt(month, lower = 1, upper = 12)
  assertInt(day, lower = 1, upper = 31)
  # 设置指定日期为 ISOdate形式
  cutoff <- ISOdate(year, month, day)
  # 筛选行
  ledger[cutoff > ISOdate(yr, mth, day)]
}
```


## (c)
```r
ex03Balance <- function(ledger, query) {
  # your code
  assertDataTable(ledger)
  assertDataTable(query)
  # 把年月日合并成一个日期列，方便比较
  ledger <- copy(ledger)[, `:=`(date = ISOdate(yr, mth, day),
    yr = NULL, mth = NULL, day = NULL)]
  # 同样给 query 加日期列
  query <- copy(query)[, date := ISOdate(yr, mth, day)]

  totals <- query[, .(
    # 计算收入
    recv = ledger[.SD, sum(amt, na.rm = TRUE), on = .(dst = account, date <= date)],  # 找出所有转给该账户、且日期在查询日期之前的交易，求和
    # 计算支出
    sent = ledger[.SD, sum(amt, na.rm = TRUE), on = .(src = account, date <= date)]  # 找出所有从该账户转出、且日期在查询日期之前的交易，求和
  ), by = seq_len(nrow(query))]  # 逐行处理 query，每行生成一个结果
  # 余额 = 收入 - 支出，然后删除临时的 date 列
  cbind(query, balance = totals[, recv - sent])[, date := NULL]
}
```
* **copy():** 创建 data.table 的**深拷贝**，修改副本不会影响原数据
	* 函数接收的 `ledger` 是外部传入的
	- 如果直接修改，会影响函数外部的原始数据
	- 用 `copy()` 保护原始数据不被修改