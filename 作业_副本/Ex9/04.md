## 计数随机数生成器调用次数
##### 核心挑战
* 给定一个函数 func，它会调用 runif() 若干次，我们需要：
	* 执行 func()
	* 统计它调用了多少次 runif()
	* 不改变全局 RNG 状态

##### 关键概念：`.Random.seed`
* .Random.seed 是 R 的全局变量，存储 RNG 状态
* 查看当前 RNG 状态：print(.Random.seed)
* 每次调用随机函数，.Random.seed 都会更新

##### 答案代码
```r
ex01CountRng <- function(func) {
  # your code
  #参数验证
  assertFunction(func)

  #保存调用前的 RNG 状态
  state.before <- .Random.seed
  #执行函数（可能多次调用 runif）
  func()
  #保存调用后的 RNG 状态
  state.after <- .Random.seed

  #恢复到初始状态
  #使用 <<- 修改全局变量，使用 <- 会创建局部变量（错误！）
  .Random.seed <<- state.before
  #重放 RNG 调用，计数直到达到终止状态
  for (i in seq_len(1000)) {
    #检查是否达到终止状态
    if (identical(.Random.seed, state.after)) {
      cat(sprintf("returning i == %s\n", i - 1))
      return(i - 1)
    }
    #调用一次 runif(1) 来推进 RNG 状态
    runif(1)
  }
  #超过1000次，返回上限
  return(1000)
}
```
* **重放和计数：** 
	* `sprintf()`: 格式化字符串函数
		* %s: 字符串占位符
		* \n: 换行符（需要 cat() 解析）
		* i-1: 要插入的值
		* cat(): 打印并解析转义字符
	* 为什么返回 `i - 1` 而不是 `i`？
```r
# 假设 func() 调用了 2 次 runif(1)

# 初始状态
.Random.seed <- state.before

# 循环迭代 1 (i = 1):
if (identical(.Random.seed, state.after))  # FALSE（还未开始）
  return(0)
runif(1)  # 第 1 次调用
# 现在 .Random.seed 前进了 1 步

# 循环迭代 2 (i = 2):
if (identical(.Random.seed, state.after))  # FALSE（前进了1步，需要2步）
  return(1)
runif(1)  # 第 2 次调用
# 现在 .Random.seed 前进了 2 步

# 循环迭代 3 (i = 3):
if (identical(.Random.seed, state.after))  # TRUE（达到目标！）
  return(2)  # 返回 i - 1 = 3 - 1 = 2 ✅
```