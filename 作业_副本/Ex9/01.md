## (a)模拟"损坏"的硬币
##### 任务要求: 创建一个函数模拟一个不公平的硬币，它有三种可能的结果

##### ✅✅ 完整解决方案最佳方法
```r
ex01BrokenCoin <- function() {
  sample(c("heads", "tails", "edge"),  #可能的结果向量
   1,  #抽取1个样本
   prob = c(0.7, 0.2, 0.1))  #对应的概率
}
```

##### 方法2：使用 `runif()` + 条件判断

```r
ex01BrokenCoin <- function() {
  val <- runif(1)  # 生成0到1之间的随机数
  
  # 概率分布：
  # [0, 0.1)     → edge   (10%)
  # [0.1, 0.3)   → tails  (20%)
  # [0.3, 1]     → heads  (70%)
  
  if (val < 0.1) return("edge")
  if (val < 0.3) return("tails")  # 0.1 到 0.3 = 20%
  "heads"                         # 0.3 到 1.0 = 70%
}
```

##### 方法3：使用 `cut()` 函数
```r
ex01BrokenCoin <- function() {
  val <- runif(1)
  as.character(
	#cut() 将连续值分割成离散区间
    cut(
      val, 
      breaks = c(0, 0.1, 0.3, 1),  #区间边界
      labels = c("edge", "tails", "heads")  #区间标签
    )
  )
}
```


## (b)Bootstrap 估计置信区间
##### 任务背景
**Bootstrap（自助法）** 是一种统计学方法，用于估计统计量的分布：
* 从原始数据中**有放回地**随机抽样
* 对每个抽样数据集计算统计量
* 重复多次，得到统计量的分布
* 从分布中计算置信区间

##### 核心概念
* **线性回归模型**
```r
# 拟合模型
model <- lm(dist ~ speed, data = cars)

# 获取系数
coefficients(model)
# (Intercept)       speed 
#   -17.579095    3.932409
```
* 模型含义：dist = intercept + speed × coefficient (刹车距离 = 截距 + 车速 × 系数)
* **Bootstrap 重采样**
```r
# 从原数据中有放回地抽取行
rows <- sample.int(
  nrow(data),           # 抽取范围：1到行数
  size = nrow(data),    # 抽取数量：与原数据相同
  replace = TRUE        # 有放回抽样（关键！）
)

# 创建新数据集
data.resampled <- data[rows, , drop = FALSE]
```

##### ✅ 完整解决方案
```r
ex02BootstrapCars <- function(data, replicates) {
  #参数验证
  assertDataFrame(data, ncols = 2)
  #检查列名是 "speed" 和 "dist"（顺序不限）
  assertNames(colnames(data), permutation.of = c("speed", "dist"))
  assertNumeric(data$speed, any.missing = FALSE)
  assertNumeric(data$dist, any.missing = FALSE)
  #检查 replicates 是整数，至少为5
  assertInt(replicates, lower = 5, tol = 0)
  
  #执行 Bootstrap
  repls <- replicate(replicates, {  #这个代码块会执行 replicates 次
    #有放回地抽样行索引
    rows <- sample.int(nrow(data), size = nrow(data), replace = TRUE)
    
    #创建重采样数据集
    data.resampled <- data[rows, , drop = FALSE]
    
    #拟合模型并返回系数
    coefficients(lm(dist ~ speed, data = data.resampled))
  })
  
  #计算置信区间
  #对每一行（每个系数）计算 25% 和 75% 分位数
  t(apply(repls, 1, quantile, c(0.25, 0.75)))
}
```
* **replicate(n, expr):** 执行表达式 n 次，将结果组合成矩阵或数组
* **`repls` 的结构：** repls 是一个 2 x replicates 的矩阵, 每列是一次 Bootstrap 的系数
* **apply(reps, 1, quantile, c(0.25, 0.75)):**
	* reps: 输入矩阵
	* 1: 按行操作
	* quantile: 应用的函数
	* c(0.25, 0.75): 传递给 quantile 的参数