## 破解在线纸牌游戏的洗牌算法
##### 游戏设定
52张扑克牌：
```r
# 4种花色 × 13种点数 = 52张牌
# 花色：C(梅花), D(方块), H(红桃), S(黑桃)
# 点数：2-10, J, Q, K, A

cards.ordered <- paste0(
  rep(c("C", "D", "H", "S"), 13),      # 重复花色
  rep(c(2:10, "J", "Q", "K", "A"), each = 4)  # 重复点数
)

# 查看前几张：
head(cards.ordered, 8)
# [1] "C2" "D2" "H2" "S2" "C3" "D3" "H3" "S3"
```

##### 洗牌函数
```r
shuffleCards <- function() {
  #获取当前时间（转换为毫秒）
  milliseconds <- as.numeric(Sys.time()) * 1000
  
  #设置随机种子（只用最后9位数字！）
  set.seed(milliseconds %% 1e9)
  
  # 随机排列52张牌
  cards.ordered[sample.int(52)]
}
```

##### 核心思路
* 1. 枚举时间窗口内的所有可能种子
* 2. 对每个种子，模拟洗牌过程
* 3. 检查前5张牌是否匹配
* 4. 找到匹配的种子 → 还原整副牌

##### 答案代码
```r
ex01InferCards <- function(cards.shuffled.head, time.estimate) {
  # ===== 步骤 1: 参数验证 =====
  assertCharacter(cards.shuffled.head, any.missing = FALSE, len = 5)
  assertPOSIXct(time.estimate, len = 1, any.missing = FALSE)
  
  # ===== 步骤 2: 枚举所有可能的时间戳 =====
  # 时间估计 ± 2000 毫秒
  for (milliseconds in as.numeric(time.estimate) * 1000 + seq(-2000, 2000)) {
    
    # ===== 步骤 3: 设置候选种子 =====
    set.seed(milliseconds %% 1e9)
    
    # ===== 步骤 4: 模拟洗牌 =====
    candidates <- cards.ordered[sample.int(52)]
    
    # ===== 步骤 5: 检查前5张牌是否匹配 =====
    if (all(candidates[1:5] == cards.shuffled.head)) {
      return(candidates)  # 找到了！返回完整牌组
    }
  }
  
  # ===== 步骤 6: 未找到匹配 =====
  stop("No seed found.")
}
```
* ``as.numeric(time.estimate`` 将 POSIXct 时间转换为数值（秒）
* ``as.numeric(time.estimate) * 1000`` 转换为毫秒
* ``seq(-2000, 2000)`` 创建 ±2000 毫秒的范围
* ``milliseconds %% 1e9`` 取模运算
	* `1e9` 取最后9位数字
* ``sample.int(52)`` 生成 1 到 52 的随机排列
* **为什么要设置 `set.seed()`？** 设置相同种子：每次结果相同
* `sample.int()` vs `sample()`
	* sample.int(n) - 生成 1:n 的随机排列
	* sample.int(5) 等价于 sample(1:5), 但 sample.int() 更快（不需要创建向量）