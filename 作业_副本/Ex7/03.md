## R 语言性能优化 - Lotka-Volterra 捕食者-猎物模型
##### 生态学基础
* **Lotka-Volterra 方程**描述了两个相互作用物种的动态：

| 物种             | 角色   | 动态          |
| -------------- | ---- | ----------- |
| 猎物 (Prey)      | 被捕食者 | 自然增长，被捕食者减少 |
| 捕食者 (Predator) | 捕猎者  | 依赖猎物增长，自然衰减 |
##### 离散化模型
* **本练习使用的离散版本：**
```r
prey(t+1) = prey(t) × qr.prey - prey(t) × predator(t) × qi.prey
predator(t+1) = predator(t) × qr.predator + predator(t) × prey(t) × qi.predator
```
* **非负性约束：**
```r
if (x(t+1) < 0) then x(t+1) = 0
```
* **参数约束**
```r
qr[1] >= 1           # 猎物自然增长率 ≥ 1（无捕食者时会增长）
0 <= qr[2] <= 1      # 捕食者自然死亡率 ≤ 1（无猎物时会衰减）
qi >= 0              # 相互作用强度非负
```

##### 参考代码
```r
ex01ComplexEcologyReference <- function(x1, qr, qi, t.max) {
  #参数验证
  assertNumeric(x1, len = 2, lower = 0, any.missing = FALSE)
  assertNumeric(qr, len = 2, any.missing = FALSE)
  if (qr[[1]] < 1 || qr[[2]] < 0 || qr[[2]] > 1) stop("qr[1] must be at least 1 and qr[2] must be between 0 and 1.")
  assertNumeric(qi, len = 2, lower = 0, upper = 1, any.missing = FALSE)
  assertInt(t.max, lower = 1, tol = 1e-100)
  
  #① 空矩阵
  result <- matrix(numeric(0), ncol = 2, dimnames = list(NULL, c("prey", "predator")))
  #② 初始状态
  xt <- x1
  #③ 循环 t.max 次
  for (t in seq_len(t.max)) {
    result <- rbind(result, xt, deparse.level = 0)  #问题1: 矩阵动态增长
    #④ 更新状态
    xt <- xt * qr + c(-1, 1) * xt[[1]] * xt[[2]] * qi
    xt <- pmax(xt, 0)  #问题2: pmax 性能
  }
  result
}
```
* **性能问题**
	* 问题 1️⃣：**动态矩阵增长**（关键问题）
		* result <- rbind(result, xt, deparse.level = 0)
		* `rbind()` 的工作原理：每次迭代复制之前的矩阵n行到新矩阵(n+1行)
	* 问题 2️⃣：**`pmax()` 性能开销**
		* xt <- pmax(xt, 0)  # 确保非负
		* `pmax()` 做了什么：
```r
# pmax() 的简化实现
pmax <- function(x, y) {
  result <- numeric(length(x))
  for (i in seq_along(x)) {
    result[i] <- if (x[i] > y) x[i] else y  # 条件分支
  }
  result
}
```

##### 优化代码
```r
ex01ComplexEcology <- function(x1, qr, qi, t.max) {
  assertNumeric(x1, len = 2, lower = 0, any.missing = FALSE)
  assertNumeric(qr, len = 2, any.missing = FALSE)
  if (qr[[1]] < 1 || qr[[2]] < 0 || qr[[2]] > 1) stop("qr[1] must be at least 1 and qr[2] must be between 0 and 1.")
  assertNumeric(qi, len = 2, lower = 0, upper = 1, any.missing = FALSE)
  assertInt(t.max, lower = 1, tol = 1e-100)
  # your code
  #优化 1：预分配矩阵（完整大小）
  result <- matrix(0, nrow = t.max, ncol = 2, dimnames = list(NULL, c("prey", "predator")))
  #初始化
  xt <- x1
  result[1, ] <- xt
  
  #优化 2：从第2次迭代开始（第1行已填充）
  for (t in seq_len(t.max)[-1]) {
    xt <- xt * qr + c(-1, 1) * xt[[1]] * xt[[2]] * qi  #状态更新
    #优化 3：用逻辑索引替代 pmax
    xt[xt < 0] <- 0
    #优化 4：直接赋值（无 rbind）
    result[t, ] <- xt
  }
  result
}
```