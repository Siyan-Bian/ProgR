## R 语言性能优化 - 逻辑斯蒂映射
##### 背景：逻辑斯蒂映射
* 逻辑斯蒂映射定义为：

	$x_{n+1}=rx_n(1−x_n)$

在生态学术语中，可以重写为：

	$x_{t+1}=\frac{1}{G}⋅x_t⋅(qr⋅G−x_t)$

其中：
- **$x_t$**：时间 $t$ 的种群数量
- **$qr$**：繁殖率（对应标准形式中的 $r$）
- **$G$**：环境容纳量（环境承载力）

##### 任务要求
* 计算 x(1), x(2), ..., x(t.max)
* 其中：x(t+1) = (1/G) * x(t) * (qr*G - x(t))
* 性能目标：比参考版本快 2 倍
* 约束条件： 
	* $t.max = 1000$
	* $qr ∈ [1, 4]$
	* $g ∈ [0, 100]$
	* $x1 ∈ [0, qr*g]$

##### 参考代码
```r
ex01SimpleEcologyReference <- function(x1, qr, g, t.max) {
  assertNumber(x1, lower = 0)
  assertNumber(qr, lower = 1)
  assertNumber(g, lower = 0)
  assertInt(t.max, lower = 1, tol = 1e-100)
  
  result <- x1  #① 从 x1 开始
  xt <- x1  #② 当前值
  
  for (t in seq_len(t.max - 1)) {  #③ 循环 t.max-1 次
    xt.next <- 1 / g * xt * (qr * g - xt)  #④ 计算下一个值
    result <- append(result, xt.next)  #问题：向量动态增长
    xt <- xt.next  #⑤ 更新当前值
  }
  result
}
```
* **性能问题**
	* 问题 1️⃣：**动态向量增长**（关键问题）
		* result <- append(result, xt.next)
		* 为什么这很慢：
			* 总操作数：$\sum_{i=1}^999 i = \frac{999 * 1000}{2} = 499500$ 次复制操作
			* 时间复杂度： $O(n^2)$ 其中 $n =$ `t.max`
	* 问题 2️⃣：**重复计算**
		* 每次迭代都重新计算
		* 低效之处：
			* `1 / g` 计算了 999 次（相同的值！）
			* `qr * g` 计算了 999 次（相同的值！）
		* 每次迭代的成本：
			* 参考版本（每次迭代）：
				* 1 次除法 (1/g)
				* 1 次乘法 (qr*g) 
				* 2 次额外乘法 
				* 1 次减法 
				* 总计：5 次算术运算
			* 优化版本（每次迭代）：
				* 2 次乘法 (g.inverse * xt * temp) 
				* 1 次减法 (qr.g - xt) 
				* 总计：3 次算术运算
			* 999 次迭代节省的操作：
				* 除法：节省 999 次操作
				* 乘法：节省 999 次操作

##### 优化代码
```r
ex01SimpleEcology <- function(x1, qr, g, t.max) {
  assertNumber(x1, lower = 0)
  assertNumber(qr, lower = 1)
  assertNumber(g, lower = 0)
  assertInt(t.max, lower = 1, tol = 1e-100)
  # your code
  #优化 1：预分配结果向量
  result <- numeric(t.max)  #提前保留内存
  result[[1]] <- x1
  
  #优化 2：预计算常量
  xt <- x1
  g.inverse <- 1 / g  #计算一次（而非 999 次）
  qr.g <- qr * g  #计算一次（而非 999 次）
  
  #优化 3：直接赋值（而非 append）
  for (t in seq_len(t.max)[-1]) {
    xt.next <- g.inverse * xt * (qr.g - xt)
    #           ↑↑↑↑↑↑↑          ↑↑↑↑
    #           常量（查找，无需计算）
    xt <- xt.next
    result[[t]] <- xt.next  #直接赋值到位置 t
  }
  result
}
```
* **`append()` 做了什么：**
```r
# append() 的伪代码
append <- function(vec, value) {
  old_length <- length(vec)
  new_vec <- allocate_memory(old_length + 1)
  
  for (i in 1:old_length) {
    new_vec[i] <- vec[i]  # 复制所有旧元素
  }
  
  new_vec[old_length + 1] <- value
  return(new_vec)
}

#之后:
result[[t]] <- xt.next  # 直接内存写入
```
* **复杂度：**
	* `append()`：每次调用 $O(n)$ → 总共 $O(n^2)$
	- 直接赋值：每次调用 $O(1)$ → 总共 $O(n)$

##### 通用教训
* **在 R 中避免：**
	* `append()`, `c()` 在循环中增长向量
	* 循环内重复计算常量表达式
* **在 R 中采用：**
	* `numeric(n)` 预分配
	* 循环前计算常量
	* 直接索引赋值 `vec[[i]] <- value`