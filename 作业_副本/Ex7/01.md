## R 语言性能优化 - 保留向量
* 编写函数 `ex01KeepOutliers(x, n.keep)`，功能是：
	- 保留向量 `x` 中最大的 `n.keep` 个值
	- 保留向量 `x` 中最小的 `n.keep` 个值
	- 返回这些"异常值"，**保持原始顺序**

* **参考代码**
```r
ex01KeepOutliersReference <- function(x, n.keep) {
  assertCount(n.keep, tol = 1e-100)
  assertNumeric(x, any.missing = FALSE)
  x.discard <- x  #复制整个向量
  #重复 n.keep 次
  for (i in seq_len(n.keep)) {
    x.discard <- x.discard[-which.max(x.discard)]  #删除最大值
    x.discard <- x.discard[-which.min(x.discard)]  #删除最小值
  }
  #返回原向量中不在丢弃列表中的元素
  setdiff(x, x.discard)
}
```

* **优化后的答案代码**
```r
ex01KeepOutliers <- function(x, n.keep) {
  # your code
  assertCount(n.keep, tol = 1e-100)
  assertNumeric(x, any.missing = FALSE)
  x.discard <- x
  # create a vector of everything that we want to discard

  ## 方案1
  # x.rank <- rank(x)
  # x[x.rank <= n.keep | x.rank > length(x) - n.keep]
  #n.keep=2:  最小的2个          最大的2个
  
  ## 方案2
  #边界情况1: 不保留任何值
  if (n.keep == 0) return(numeric(0))
  #边界情况2: 保留所有值
  if (2 * n.keep >= length(x)) return(x)

  #排序并找到阀值
  x.sorted <- sort(x)
  cutoff.lower <- x.sorted[[n.keep]]
  cutoff.upper <- x.sorted[[length(x) - n.keep]]
  #筛选
  x[x <= cutoff.lower | x > cutoff.upper]
}
```
* **rank():** 返回每个元素在排序中的位置
	* 示例:
```r
x      <- c(5,  2,  9,  1,  7,  3,  8,  4,  6)
#索引    <- c(1,  2,  3,  4,  5,  6,  7,  8,  9)

#排序后
sorted <- c(1,  2,  3,  4,  5,  6,  7,  8,  9)
#对应原索引 c(4,  2,  6,  8,  1,  9,  5,  7,  3)

#rank() 返回：每个元素在排序中的位置
x.rank <- c(5,  2,  9,  1,  7,  3,  8,  4,  6)
#           ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
#           5   2   9   1   7   3   8   4   6 ← 排名
```
