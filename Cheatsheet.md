* **setDT():** 转换为 data.table
* 用 **.()** 可以命名多列
* `:=` :引用修改
	* 创建新列：`dt[, new_col := value]`
	* 删除列：`dt[, col := NULL]`
	* 修改多列：`dt[, `:=` (col1 = val1, col2 = val2)]`(反引号包裹`:=`)
* **`=`**: 传递参数
* **.SD**: 当没有指定 `.SDcols` 时，`.SD` 包含**除分组列以外的所有列**
* **.SDcols = patterns("^sensor")**: 正则表达式选择特定列
* **cbind():** 横向，列合并
* **rbind():** 纵向，行合并
* **升序降序:**
	* `dt[order(-列名)]`: 降序
	* `dt[order(列名)]`: 升序
* **setorderv(dt, cols, order = 1):** 按指定列排序
	* `c("missings", "quality")`: 先按 missings 排序，再按 quality 排序
	* `order = -1`: 降序排列
		* 1 或 c(1, 1): 全部升序
		* -1 或 c(-1, -1): 全部降序
		* c(1, -1): 第一列升序，第二列降序
* **merge():** 合并与连接
	* `merge(x, y, by, all, all.x, all.y, ...)`
		* all: 全外连接（保留两表所有行）
		* all.x: 左连接（保留左表所有行）
		* all.y: 右连接（保留右表所有行）
	* **左连接**(不用merge): `y[x, on = "..."]` **=>** 保留 **x** 的所有行
		* 多个连接键时 `on = .(a, b)` 或 `on = c("a", "b")`
	* **反向连接:** 返回只在 x 表中但不在 y 表里的行
		* `x[!y, on = "..."]`
	* **滚动连接:** `x[!y, on = "...", roll = TRUE]`
		* **roll** 参数值:
			* roll = TRUE / Inf -----向前滚动（找 ≤ 的最近值）
			* roll = -Inf -----向后滚动（找 ≥ 的最近值）
			* roll = n -----最多滚动 n 个单位
			* roll = "nearest" -----找最接近的（前或后）
* **分组聚合:**
	* `data[, .(新列 = 聚合函数(列)), by = 分组列]`
		* **需要手动排序** --- `data[, .(), by][order()]`
		* 根据多列分组: by = .(..., ...)
* **切片:**
	* 取前n行：`dt[1:n]`
	* 取后n行：`tail(dt, n)`
	* 取特定位置的行：`dt[c(a, b, c)]`
	* 取最大值的行：`dt[order(-quantity)][1:n]`
	* 取最小值的行：`dt[order(quantity)][1:n]`
	* 按比例取样(z.B. 取前10%)：`dt[1:(.N * 0.1)]`
* **去重:**
	* 对指定列去重，保留所有列：`unique(dt, by = c("store.loc", "product.id"))`
	* 对指定列去重，只保留这些列：`unique(dt[, .(store.loc, product.id)])`
* **last():** 取最后一个元素
* **copy():** 创建外部传入的 data.table 的**深拷贝**，修改副本不会影响原数据
* **setnafill(dt, fill = 0, cols = "列名"):** 原地修改，填充 **NA** 值 (只能填充**数值列**)
	* 场景: 多列、直接修改、追求效率 (只在**datatable**)
* **nafill():** 返回新向量，填充 **NA** 值，需要赋值
	* 场景: 单列、需要保留原数据 (可以在**向量**和 **datatable**)
* **dcast(data, 行变量 ~ 列变量, value.var = "填充值"):** 长格式转宽格式 (dataframe中也可使用)
	* 行变量: 各一行
	* 列变量: 各一列，展开为列
	* 填充值: 填入对应格子的值
	* **注意:** 使用之后可能会打乱行顺序，需要用原始变量顺序做连接，恢复顺序 (`[...$..., on = "...."]`)