## 随机数的概念与原理
##### 为什么需要随机性？
- 模拟中抽取概率分布的点
- 概率算法（例如，通过随机评估点来估计期望值）
- 模拟游戏（如掷骰子、洗牌）
- 创建密码或加密密钥

##### 计算机的确定性与解决方案
- **根本矛盾**: 计算机程序是**确定性**的 
- **解决方案**:
    - **硬件生成随机性**: 基于物理现象（如电路中的电噪声），缓慢且昂贵 
    - **伪随机数生成器 (PRNG/RNG)**:
        - 通过**确定性**的计算产生数字，但模式极其复杂，足以达到随机目的 
        - **特点**: 快速，但并非“真正”随机 
        - **R 语言中的函数**: 以 `r` 开头的函数（如 `runif`、`rexp`、`rbinom` 等）以及 `sample` / `sample.int`

##### PRNG 工作流程（中平方方法 Middle-Square Method 示例）
- **PRNG 一般过程** 
	- 1.  **种子 (Seed)**：起始数字 `x`
	- 2.  **初始化/播种 (Seeding)**：设置初始值
	- 3.  **状态 (State)**：PRNG 当前的状态（一系列 `x` 值）
	- 4.  **生成随机数** (Output) 。 5.  **更新状态** (New State) 

- **中平方方法步骤**（玩具示例）: 取 `n` 位数 `x` → 计算 x2 → 取中间 `n` 位作为新的 `x` → 重复


## R 语言中的 PRNG
##### 播种与状态管理
- **设置种子**: 使用 `set.seed()`

- **RNG 状态变量**: `.Random.seed`。它是一个大型数字向量，在设置种子或使用随机函数后才会存在 
    - `.Random.seed` **不等于** `set.seed()` 传入的值

- **核心原则——可复现性 (Reproducibility)**:
    - 设置**相同的种子**会产生**相同的随机值**
    - 使用**相同的 RNG 算法** (`RNGkind()`)，相同的种子将导致相同的初始状态

##### 随机值抽取 (Drawing)
- **随机数函数**: 以 `r` 开头，用于从特定分布中抽取随机值
    - **常见分布**: 均匀分布 (`runif`)、指数分布 (`rexp`)、正态分布 (`rnorm`) 等

- **内部机制**: R 通常先抽取一个或多个**均匀分布**的值，然后基于此构建其他分布的随机变量（例如，`rexp() = -log(runif())`）

- **状态推进**: 每次调用随机数函数都会推进 RNG 状态，这个过程是**确定性**的
    - **重要性**: 必须按照**相同的顺序**调用**相同的随机函数序列**，才能产生相同的随机结果序列 
    - 注意：不同的随机调用可能会以不同的步长推进状态

##### R 中分布函数的四种类型
|**功能**|**前缀**|**描述**|**均匀分布示例**|
|---|---|---|---|
|**随机值**|`r`|随机数生成|`runif()`|
|**概率/密度**|`d`|概率密度函数 (PDF)|`dunif()`|
|**累积分布**|`p`|累积分布函数 (CDF), $P(X \le x)$|`punif()`|
|**分位数**|`q`|分位数函数, $F^{-1}$|`qunif()`|

## PRNG 的主要应用场景
- **假设检验和 p-值估计**: 通过模拟 H0​ 下的数据来计算 p-值
- **自助法 (Bootstrapping)**: 有放回地抽取样本并拟合模型（`sample(values, replace = TRUE)`）
- **置换检验 (Permutation tests)**: 随机打乱某一数据列，检验其相关性
- **随机搜索 (Random Search)**: 用于优化超参数，相比网格搜索能更高效地探索参数空间 
- **可视化与数据探索**: 随机抽样大型数据集以获取近似视图 
- **特定算法**: 马尔可夫链蒙特卡洛 (MCMC)、进化算法、数据增强技术（多由 R 包实现）


## R 语言中随机数的实用技巧 (Recipes)
|**目的**|**推荐做法 (Do)**|**不推荐做法 (Dont)**|**注意要点**|
|---|---|---|---|
|**重复实验 $n$次**|`result <- replicate(n, experiment())`38|`for` 循环或 `vapply`39393939|实验表达式不依赖于索引 $i$ 时使用 `replicate()` 40。|
|**获取 [1, $n$] 范围随机整数**|`sample(n, size = 1)` 或 `sample.int(n, size = 1)` 41|`sample(seq_len(n), size = 1)` 42|当 `n` 为标量时，`sample(n)` 自动从 $1$ 到 $n$ 采样 43。|
|**打乱向量 $v$**|`v[sample(length(v))]` 或 `v[sample.int(length(v))]` 4444|`sample(v)` 45|若 $v$ 长度为 1（标量），`sample(v)` 会被解释为 `seq_len(v)`46。|
|**打乱表格行顺序**|`iris[sample.int(nrow(iris)), ]` 47|-|-|
|**按比例抽样**|`iris[sample.int(nrow(iris), size = nrow(iris) * 0.1), ]` (10% 抽样) 48|-|-|
|**有放回抽样**(Bootstrap)|`iris[sample.int(nrow(iris), replace = TRUE), ]` 49|-|-|


## 高级可复现性与安全性问题
##### RNG 算法与版本控制
- **更改算法**: 使用 `RNGkind()` 或 `set.seed(n, kind = ...)` 
- **版本兼容**: 使用 `RNGversion("<R version>")` 来匹配特定 R 版本（如 `"3.6.0"`）的 PRNG 默认设置，以确保旧代码的可复现性 
- **并行计算**: `"L'Ecuyer-CMRG"` 算法适用于并行化

##### 安全性与熵 (Entropy)
- **风险**: 如果知道**种子**和**代码**，就可预测随机数
- **预测**: 如果知道足够的随机值，可以推导出 RNG 状态并预测后续数字
- **建议**: 用于安全目的（如加密密钥）时，必须使用**高熵**（真正随机）的种子和**密码学安全**的 PRNG 
- **默认种子**: R 在未设置种子时使用**系统时间**和**进程 ID**，**不可复现** 。生产代码中**务必设置种子**

##### 可复现性挑战与状态缓存
- **顺序依赖问题**: 随机数调用的顺序**至关重要** 
    - **破坏因素**: 添加/删除随机调用、手动运行随机函数、代码中使用**可选**（如缓存）或**有条件**的代码块，都可能改变 RNG 状态的推进顺序，导致结果不可复现
    - **外部影响**: 包版本或行为的更改也可能影响调用顺序
        
- **解决方案**:
    - **缓存 RNG 状态 (最佳实践)**: 在可选代码块前后保存和恢复 `.Random.seed`
        - **保存**: `s <- .Random.seed` 
        - **恢复** (在函数内部需用 `<<-`)：`.Random.seed <- s` / `.Random.seed <<- s`
    - **独立流 (L'Ecuyer-CMRG)**: 在可选部分前使用 `parallel::nextRNGStream(.Random.seed)` 获取下一个独立的 RNG 状态，并在之后恢复

##### 其他随机性来源
- **外部程序**: 调用使用随机性的外部程序（如 Python 代码）时，也需要设置其相应的种子 
- **多次重复实验**: 如果在**不同的 R 会话**中重复实验（如蒙特卡洛模拟），应使用**不同的种子**，以确保运行结果的真正独立性，避免 PRNG 结果相关性导致的偏差