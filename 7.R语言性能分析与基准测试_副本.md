## Profiling（性能分析）
* **什么是 Profiling？**
	* **目的**：代码能运行但很慢，需要找出瓶颈
	- **作用**：识别代码中的"热点"（hotspot）
- **示例案例：蒙特卡洛估算 π**
	- 方法原理：
		- 在 [-1, 1] × [-1, 1] 区域均匀采样点
		- 检查每个点是否在单位圆内（x² + y² < 1）
		- 圆内点数比例 ≈ 圆面积 / 正方形面积
		- 公式：**4 × (圆内点数 / 总点数) ≈ π**
	- 示例代码结构：
```r
estimatePi <- function(n) {
  # 采样 n 个点
  # 测试每个点是否在圆内
  # 计数圆内点数
  # 返回 π 的估计值
}
```
* **profvis 包详解**
	* 核心功能
		* 可视化代码执行时间
		- 显示内存分配/释放
		- 时间轴展示函数调用
	- 界面解读
		- 右侧数字: 该行代码执行时间（毫秒）
		- 内存信息: 内存分配/释放情况
		- 时间轴: 各时间点正在执行的函数
		- 连续行: 如第12-13行，13行时间包含在12行内
	- 使用方法
```r
profvis({
  # 你的代码
})
```
* **重要注意事项**
	* **惰性求值（Lazy Evaluation）陷阱**
		* 问题：
			* 函数参数只在**首次需要时**才计算
			- 可能导致性能分析结果混淆
		- 示例：
```r
myPrint <- function(x) {
  assertNumber(x)  # x 在这里才被计算！
  print(x)
}

profvis({
  myPrint(estimatePi(10000000))  # 看起来 checkmate 很慢？
})
```
* 解决方法：强制求值（Forcing）
```r
myPrint <- function(x) {
  force(x)  # 在函数开头强制计算 x
  assertNumber(x)
  print(x)
}
```
* **profvis 技术特点**
	- **基于 Rprof** 实现
	- **采样分析器**：每 10ms 采样一次（可调整 `interval` 参数）
	- **非确定性结果**：每次运行可能略有不同
	- **可能遗漏**：运行极快的代码可能被跳过


## Benchmarking（基准测试）
* **什么是 Benchmarking？**
	* **目的**：不知道哪种方法更快，需要测量对比
	- **作用**：比较不同实现方式的性能
- **工具1：system.time()**
	- **用途:** 单次执行的时间测量
	- **返回值解释**
		- user: R 使用的总 CPU 时间
		- system: 系统时间（图形/网络/文件操作）
		- elapsed: 实际经过的总时间
		- **注意：** `elapsed` 可能 < `user`（多核并行时）
	- **参数**
		- `gcFirst`：是否先清理内存
			- `TRUE`：更确定但稍慢
			- `FALSE`：更快但不太确定
	- **使用示例**
```r
system.time({
  result <- myFunction(data)
})
```
* **工具2：microbenchmark 包**
	* **用途**
		* 多次重复执行
		- 计算统计数据
		- **比较不同方法**的性能
	- **主要参数**
		- ...: 要测试的表达式（可命名）
		- times: 每个表达式重复次数（默认100）
		- check: 检查结果是否相等<br>`"equal"` / `"equivalent"` / `"identical"` / `NULL`
	- **使用示例**
```r
library(microbenchmark)

result <- microbenchmark(
  for_loop = {
    result <- numeric(1000)
    for (i in seq_len(1000)) result[i] <- i^2
  },
  vectorized = {
    result <- (1:1000)^2
  },
  times = 50
)
```
* **结果解读**
	* **统计指标**

| 指标     | 说明    | 推荐度                         |
| ------ | ----- | --------------------------- |
| min    | 最小值   | -                           |
| lq     | 下四分位数 | -                           |
| mean   | 平均值   | 易受异常值影响                     |
| median | 中位数   | 推荐(更能抵抗异常值)                 |
| uq     | 上四分位数 | 推荐(其他程序随机占用资源导致的偶然慢速不会影响结果) |
| max    | 最大值   | -                           |
	* **可视化：** plot(result) #自动绘制对比图（注意对数刻度）
* **最佳实践与注意事项**
	* **正确做法**
		* **用 system.time**：测量耗时较长的单个函数
		- **用 microbenchmark**：比较多个小函数/表达式
		- **看 median/uq**：而非 mean
		- **在同一次调用内比较**：不要跨次比较结果
	- **避免做法**
```r
# 错误示例：不要这样！
system.time(
  for (i in seq_len(100)) myFun(x)
)
# 应该用 microbenchmark(myFun(x), times = 100)
```
* **基准测试的局限性**

| 局限     | 说明                                      |
| ------ | --------------------------------------- |
| 结果波动   | 不同运行相差可达 2 倍<br>CPU 温度、turbo boost 都会影响 |
| 只在内部比较 | 仅在同一次 `microbenchmark()` 内比较            |
| 代码交互   | 可能遗漏 GC、CPU 缓存等交互影响                     |
| 数据规模   | 小数据快 ≠ 大数据快                             |
| 极致优化   | 到这一步考虑用 **Rcpp**                        |

## 编写高效代码的原则
* **优化前三问**
	* ❓ 这段代码**真的是瓶颈**吗？（用 profvis 确认）
	- ❓ 优化的**速度提升值得**付出的代价吗？
	- ❓ 会不会**牺牲代码可读性和可维护性**？
- **优化策略**
	- 避免不必要的慢代码 -> 只优化热点代码 -> 平衡速度与可维护性
- **优化决策流程图**
	- 代码慢？ -> profvis 找热点 -> 是热点？ -> 否 -> 不优化 -> 是 microbenchmark 对比方案 -> 速度提升明显？ → 否 → 不优化 -> 是 不损害可读性？ -> 否 -> 慎重考虑 -> 是 采用优化方案 

## 工具速查表

| 需求   | 工具             | 用法                                          |
| ---- | -------------- | ------------------------------------------- |
| 找瓶颈  | profvis        | profvis({ code })                           |
| 单次计时 | system.time    | system.time(expr)                           |
| 对比方法 | microbenchmark | microbenchmark(method1, method2, times=100) |
| 强制求值 | force          | force(x)                                    |
| 可视化  | plot           | plot(benchmark_result)                      |
