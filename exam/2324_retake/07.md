```r
longestRepeatedSubString <- function(s) {
  assertString(s)
  
  # 长度小于2，不可能有重复子串
  if (nchar(s) < 2) return("")
  
  # 从最长可能长度开始尝试，一旦找到就立即返回
  for (try.length in seq(floor(nchar(s) / 2), 1, by = -1)) {
    
    # 获取所有该长度的子串切片
    slices <- vapply(seq(0, nchar(s) - try.length), function(startpos) {
      substr(s, startpos + 1, startpos + try.length)
    }, character(1))
    
    # 遍历每个切片，与非重叠的其他切片比较
    for (slice.pos in seq_along(slices)) {
      slice.current <- slices[[slice.pos]]
      
      # 获取非重叠的后续切片
      slices.other.nonoverlapping <- tail(slices, -(slice.pos + try.length - 1))
      
      # 如果当前切片在非重叠切片中出现，返回
      if (slice.current %in% slices.other.nonoverlapping) return(slice.current)
    }
  }
  return("")
}
```
* **外层循环 - 尝试不同长度**
	* 例子：
```r
s = "banana"  # 长度 6

seq(floor(6/2), 1, by = -1)
# = seq(3, 1, by = -1)
# = c(3, 2, 1)

# 先尝试长度3，再尝试长度2，最后尝试长度1
# 从长到短，贪心策略
# 为什么最大是 `n/2`？--- 字符串长度 = 6, 要非重叠出现两次，每个子串最多占 6/2 = 3
```