
## R Track - 条件与错误处理 (Conditions and Errors)

* **处理函数失败的三种方式**
	* 当函数无法完成预期任务时（如错误输入、内存不足、无解等），有三种处理方法：
		1. **返回期望值但给出警告**
		2. **返回表示问题的值**
		3. **抛出错误条件** (signal an error-condition)

* **警告 (Warnings)**
	* **何时使用警告**
		* 函数返回可能不是期望的结果（如 NA）
		- 函数被新函数取代，但不想破坏旧代码
		- 调用方式可能产生错误结果
	- **警告的使用方法**
		- warning("警告信息")
	- **抑制警告**
		- suppressWarnings(expression)
	- **控制警告行为**
		- options(warn = -1)  # 忽略所有警告
			options(warn = 0)   # 计算结束时返回警告（默认）
			options(warn = 1)   # 立即打印警告
			options(warn = 2)   # 将警告视为错误

* **消息 (Messages)**
	* **消息的用途**
		* 应代替 `cat()` 或 `print()` 通知用户重要信息
		- 是警告的弱化形式
	- **使用建议**
		- 不要过度使用消息
		- 最好使用配置参数使消息可选
		- 或使用 `lgr` 包配置输出日志
	- **抑制消息**
		- suppressMessages(expression)
		- **注意**：没有类似 `options(warn=)` 的消息控制机制

* **返回表示问题的值**
	* **合理的情况**
		* 返回 `NULL` 或空向量表示"无解"是自然表示时
		- 这是该问题域的自然表示方式
	- **通常不推荐**
```r
result <- someFunction()
if (is.null(result)) {
  # 需要检查是否出错
}
```

* **抛出错误 (Signaling Error-Condition)**
	* **使用 `stop()` 函数**
		* stop("错误消息")
	* **其他抛出错误的方法**
		- `checkmate` 包的 `assertXxx()` 函数
		- `stopifnot()` 函数
	- **错误的控制流**
		- **正常控制流**：函数调用 → 返回值 → 继续执行
		- **错误控制流**：函数调用 → 错误 → 展开调用栈 → 到达交互会话（或退出程序）
	- **捕获错误**
		- 使用 `tryCatch()` 或 `try()`
		- 使用 `on.exit()` 确保即使出错也执行某些操作

* **on.exit() - 退出时执行**
	* **执行时机**
		* 函数正常退出时
		- 函数因错误退出时
		- 用户按 Ctrl-C 或 RStudio 的停止图标时
	- **注意事项**
		- `on.exit()` 中不要花费太多时间，否则用户可能再次按 Ctrl-C
		- 用于"清理"操作，避免对象处于半损坏状态
		- **重要警告**：清理处理程序理论上也可能被 Ctrl-C 中断
		- 不要完全依赖 `suspendInterrupts()`
	- **基本用法**
```r
myFunction <- function() {
  on.exit(print("函数退出时执行"))
  # 函数代码...
}

#多次调用
on.exit(expr1)
on.exit(expr2)  # 会替换 expr1
on.exit(expr3, add = TRUE)  # 不会替换，而是添加
```

* **tryCatch() - 捕获错误**
	* **基本结构**
```r
tryCatch(
  expr = {
    # 尝试执行的代码
  },
  error = function(cond) {
    # 错误处理函数
  },
  finally = {
    # 无论如何都会执行的代码
  }
)
```
* **返回值**
	* 无错误：返回 `expr` 的值
	- 有错误：返回错误处理函数的返回值
	- **错误处理函数的参数**
```r
error = function(cond) {
  message <- conditionMessage(cond)
  call <- conditionCall(cond)
  # 处理错误...
}
```
* **捕获其他信号**
```r
tryCatch(
  expr = {...},
  warning = function(cond) {...},
  message = function(cond) {...},
  error = function(cond) {...}
)
```
**注意**：如果 `tryCatch` 捕获了警告/消息，则不会显示警告/消息（除非再次调用 `warning()` / `message()`）

* **自定义错误类**
	* **用途**
		* 对不同类型的错误做出不同反应
		- 提高错误处理的精确性
	* **定义自定义错误**
		* errorCondition(message = "错误消息", class = "myCustomError")
	* **捕获特定错误**
```r
tryCatch(
  expr = {...},
  myCustomError = function(cond) {
    # 处理自定义错误
  },
  error = function(cond) {
    # 处理其他错误
  }
)
```

* **中断条件 (Interrupt Condition)**
	* **用户中断**
		* 用户按 Ctrl-C
		- RStudio 中点击停止图标
		- 产生 "interrupt" 条件
	- **注意事项**
		- **通常是个坏主意**！用户想退出时程序应该退出
		- 清理操作应使用 `on.exit()` 而非捕获中断
		- 如果必须使用，要小心：用户可能快速连续按 Ctrl-C，也会中断这里的代码
	- **捕获中断**
```r
tryCatch(
  expr = {...},
  interrupt = function(cond) {
    # 处理中断
  }
)
```

* **调试注意事项**
	* **重要**：`tryCatch` 会干扰调试！
		如果只想修改错误消息，使用 `withCallingHandlers` 代替 `tryCatch`

* **try() - tryCatch 的简化版本**
	* **基本行为**
		* res <- try(expr)
		* **成功时**：返回计算结果
		- **失败时**：返回 "try-error" 对象
	- **静默模式**
		- res <- try(expr, silent = TRUE)  # 抑制错误消息
	- **为什么优先使用 tryCatch**
		- 更灵活
		- 如果函数合法返回 "try-error" 对象怎么办？
	- **检查是否出错**
```r
if (inherits(res, "try-error")) {
  # 处理错误
}
```


## 期望掌握的知识点

* **R Track 知识点总结**
	* ✅ **使用不同的信号**：
		- `stop()` - 错误
		- `warning()` - 警告
		- `message()` - 消息
		
		✅ **忽略消息/警告**：
		- `suppressMessages()`
		- `suppressWarnings()`
		
		✅ **改变警告的后果**：
		- `options(warn=)`
		
		✅ **使用 tryCatch**：
		- 捕获错误 / `stop()`
		- 捕获使用 `errorCondition()` 创建的自定义错误
		
		✅ **了解 try()**：
		- 但优先使用 `tryCatch`
		
		✅ **使用 on.exit()**：
		- 在离开函数前执行操作

## Dev Track - 模块化编程 (Modular Programming)

* **课程声明 (Caveat Emptor)**
	* 这部分内容是基于讲师经验的"软件可能如何工作"的观点，而非绝对真理。不同的人可能有不同的表述或侧重点

* **软件的构建块 (Building Blocks)**
	* **核心概念**
		* 编写软件解决问题时，需要在代码中"表示"问题的相关"概念"
	* **示例 1：两数之和**
		* **问题**：两个给定数字的和是多少？
			**需要表示**：
			- 数学运算和对象（如数字）
			- R 已内置，因此程序只需一行：**sum(a, b)**
	- **示例 2：井字棋**
		- **问题**：在给定情况下，某个移动是否是获胜移动？
			**需要表示**：
			- "井字棋中的移动"
			- "给定情况"（即"状态"）
			- "获胜"的概念
			**R 中的表示**：
			- 游戏状态 ⇨ 3x3 矩阵，包含 "X" 和 "O"
			- 移动 ⇨ 字符串，表示列（A、B、C）和行（1、2、3），如 "B1"
			- 检查"获胜" ⇨ 检查三个 "X" 或 "O" 是否在一条线上
	- **示例 3：电影推荐**
		- **问题**：喜欢电影 A 的人统计上是否也会喜欢电影 B？
			**需要的概念**：
			- "统计上""喜欢"某物 ⇨ 数据库中相似人群的信息
			- "数据库" ⇨ 合适格式存储数据的文件
			    - 需要"文件"
			    - 需要约定的数据存储格式
			- "相似人群"的概念
			    - "相似性"可基于矩阵计算
			        - 需要矩阵运算
			        - ...
			- ...
			**实现方式**：
			
			- R 没有直接提供，可以自己实现
			- 但通常依赖构建块，如数据库包或矩阵分解包

* **构建块的复杂性**
	* **软件复杂性的决定因素**
		- 可用的构建块类型
		- R 的优势：
		    - 内置数字表示，便于计算
		    - 提供矩阵运算和统计函数
		    - 有许多 R 包，特别是统计、数据科学、机器学习相关
	* **自己构建的块**
		- 目前：课程告诉你要写什么函数
		- 进阶：函数会互相调用（如 ex02 调用 ex01）
		- 目标：培养对由小部分组成的功能的意识
		- 现实世界：需要自己决定写什么函数！

* **软件的模块化**
	* **软件组件 (Components)**
		* 软件由以下组件构成/使用：
			- R 包
			- 函数
			- 类/对象（稍后学习）
			- 文件
			- ...
	- **组件提供的抽象**
		- **示例 1：ggplot2 包**
			- 文档引用："基于'图形语法'的'声明式'图形创建系统"
			- 提供的抽象：
			    - `geom_point()`（"绘制点"）
			    - `geom_line()`（"绘制线"）
			- ggplot2 本身是一个抽象：
			    - 可以在不了解其内部工作原理的情况下使用
			    - 可以用相同函数但不同实现（如 3D）编写替代包
		- **示例 2：lm() 函数**
			- 文档引用："lm 用于拟合线性模型"
			- `lm()` 是拟合线性模型过程的抽象
			- `lm()` 的结果是这种模型的抽象
			    - 可以获取 `$coefficients`
			    - 可以调用 `summary()` 等
		- **示例 3：evaluate_submission.R 文件**
			- 引用："可以用 Rscript evaluate_submission.R 运行脚本来检查所有结果"
			- 文件提供了正确/错误解决方案概念的抽象

* **好的软件组件**
	* **主要关注：函数**
		* 虽然文件、R 包、对象/类也是"组件"，但最需要关注的是**函数**
	* **何时需要考虑写什么函数**
		* 开始编写自己的软件时
		- 如为学士/硕士论文、实习等分析数据时

* **有用的组件/抽象的特征**
	* **代表有用的内容**
		* 代表某个"有用"的东西（对象、过程、概念）
		- **取决于上下文**！
	- **代表的内容简单**
		- **简单**："线性模型"或"绘制点"
		- **不简单**："当给定偶数个数据点时绘制点，否则将图片旋转 90°"
		- 也取决于上下文
	- **与类似级别的其他抽象有意义地"正交"**
		- 提供其他"同级"组件无法轻易达到的功能
		- 例子：
		    - 当存在 `plotPoints(size = ...)` 函数时
		    - `plotPointsOfSize3()` 函数就不太有用
		- **但**：简化"常见情况"的函数（如 ggplot2 中的 `qplot()`）出于可用性原因可能有意义
	- **抽象不太"泄漏"**
		- 通常不需要知道它如何工作就能理解它做什么
		- 例子：
		    - 可以在 R 中使用矩阵和矩阵运算（如 `%*%`）
		    - 无需考虑矩阵在 R 中如何工作
		- **注意**：大多数抽象都有一定程度的泄漏
		- **泄漏抽象的示例**：
```r
# "数字"是实数的泄漏抽象
0.1 + 0.2 == 0.3  # FALSE!
```

* **有用的函数的特征**
	* **做有用的事**
		- 解决问题所需的事情！
	* **函数功能简单**
		- 可以用几句话解释
		- 参见前面关于"简单"的说明
	* **与其他函数"正交"**
		- 不应有多个函数做几乎相同的事情
		- 应该有一个函数，用函数参数控制行为细节
		- 关于简化"常见情况"：
		    - 通常使用"默认"函数参数就足够了
		    - 例如：`plotData <- function(data, type = "points")`
	* **函数提供的抽象不太"泄漏"**
		- 不需要知道它如何解决问题

* **设计函数**
	* **函数拆分示例**
```r
#示例A
ex03FizzBuzz <- function(up.to) {
  # 整个函数代码在一起
}

#示例B
makeSequence <- function(up.to, number) {
  seq_len(floor(up.to / number)) * number
}

ex03FizzBuzz <- function(up.to) {
  # 使用 makeSequence
  multiples.of.3 <- makeSequence(up.to, 3)
  multiples.of.5 <- makeSequence(up.to, 5)
  # ...
}
```

* **为什么 B 更好**：
	* A 只是任意剪切粘贴部分代码
	- B 做了更多：识别出"大于 0 且小于 'up.to' 的等间距数字序列"被多次使用
	- B 避免重复编写 `seq_len(floor(up.to..)) * number` 代码，简化了事情

* **何时编写函数**
	* **情况 1：lapply()、vapply() 等需要时**
		* 但匿名函数不是我们这里讨论的"组件"
	* **情况 2：发现自己复制粘贴代码，只改变变量名**
		* **DRY 原则**："Don't Repeat Yourself"（不要重复自己）
		- 将复制粘贴的代码转换为函数
		- 这是前面示例 B 的情况
	- **情况 3：代码涉及可用简短句子解释的逻辑概念/操作**
		- 将此代码做成函数
		- 使用反映概念/操作的函数名、参数名和变量名
		- 例子：
		    - 从特定格式的文件读取数据，即使代码只读取一次
		    - 计算复杂的数学函数，即使此代码只使用一次
	- **情况 4：代码/函数变得复杂，可以用更小的部分解释**
		- 代码有深层嵌套的循环或 if-else 块
		- 代码长度远超过一屏
		- **解决方法**：拆分为函数，即使情况 1 或 2 不适用
		- 这看起来像示例 A（如果忘记情况 2 适用的话！）

* **如何编写函数**
	* **文档**
		* **简短句子**（或段落，如有必要）描述函数功能
		- **列出函数参数**，详细说明：
		    1. 类型
		    2. 用途
		- **返回值类型**，以及如果不明显，返回值是什么
	- **函数头**
		- **函数名**应具有描述性且明确
		- **有默认值的参数**通常应放在无默认值参数之后
		- **尽量不要有太多参数**
	- **函数体**
		- **以断言 (asserts) 开始**是好做法：
			1. 确保函数不会用意外值调用并以意外方式失败
			2. 让查看函数的人清楚函数期望什么输入
	* **文档和断言的必要性**
		* 取决于函数的大小和复杂性。例如，一行代码可能不需要：
```r
# 简单一行函数可能不需要详细文档
square <- function(x) x^2
```

* **读者有隧道视野 (Tunnel Vision)**
	* **代码应该易于理解**
		* **无需同时看太多行**：
			- 将代码分块为合理大小的函数
			    - 理想情况下应适合一屏
			- 以及合理大小的文件
		- **无需同时记住太多事情**：		
			- **限制"嵌套深度"**：
			    - 避免 for 循环内的 if 子句内的 for 循环内的...
			- **限制函数参数数量**：
			    - 用户不应总是需要查看文档
			- **限制单个函数的角色**：
			    - 如果不能用一句话总结其效果，考虑拆分
			- **更一般的相关概念**：
			    - 追求松耦合 (loose coupling)
			    - 限制代码各部分之间的相互依赖
			    - 限制一部分依赖另一部分特定实现细节的程度

* **编程风格回顾**
	* 记住编程风格部分的内容：
		- 良好的命名
		- 代码结构
		- 可读性原则


## 期望掌握的知识点

* **Dev Track 知识点总结**
	* ✅ **通过将大问题分解为子问题来解决**：
		- 然后为子问题编写函数
	- **✅ 函数应履行明确的目的**：
		- 可以（通常应该）用几句话解释
	- ✅ **函数和参数名称应具有描述性**
	- ✅ **应记录函数参数和返回值**：
		- 特别是它们的预期类型
	- **注意**：
		- 这在作业/考试中不易测试，因此"不可考"
		- 但记住这些会让你自己的项目更轻松
